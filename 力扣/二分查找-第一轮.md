# 二分查找-第一轮 刷题笔记

## 前言

关于二分查找，704题的题解区有一篇文章分析得很到位。原文：[二分查找细节详解，顺便赋诗一首 - 二分查找 - 力扣（LeetCode）](https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/)

> 二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：思路很简单，细节是魔鬼。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 <= 还是 <。
>
> 你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。

这段评价真是一阵见血。

我觉得，大家都懂得二分思想，但是**只有能够独立写出无bug、一次性AC的二分算法，才算是把二分学明白了**。如果只是靠看评论、看题解、看提交不通过的报错，最终跌跌撞撞把一道题做出来了，那么这不是我想要达到的水平。

## 背景

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

> **示例 1:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> ```
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

这题其实我在2021.11.06做过一次，不过当时没有记录，也没有写笔记。这次重做一遍就当复习吧，顺便补一下笔记。

**看到有序数组+无重复元素。就要想到用二分查找了**，因为这是二分查找最经典的应用场景。

不过我第一次做的时候甚至还写不出来一个能用的二分，只好直接套模板，就是下面的模板1。

2022.01.29

## LeetBook 二分查找模板1

#### 模板1

```java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0) {
      return -1;
  }
  int left = 0;
  int right = nums.length - 1;
  while(left <= right){
    //避免(left + right)溢出
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){
        return mid;
    }
    else if(nums[mid] < target) {
        left = mid + 1;
    }
    //相当于else if(nums[mid] > target)
    else {
        right = mid - 1;
    }
  }
  //退出循环时，left > right
  return -1;
}
```

#### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

> **示例 1：**
>
> ```
> 输入：x = 4
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：x = 8
> 输出：2
> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
> ```
>
> **提示：**
>
> - `0 <= x <= 2^31 - 1`

最终我还是参考了评论区，才能AC这道题。

因为我自己写的时候没能解决mid * mid溢出这个问题，事实上由于mid最大可以取Integer.MAX_VALUE / 2（当left=0, right=Integer.MAX_VALUE），这就意味着mid * mid的值一旦溢出，那将毫无规律可言。可能是正数，可能是负数，可能很大，可能很小。*（第一次提交：解答错误）*

评论区大佬的思路是，不要判断mid * mid == x，而是判断x / mid == mid，马上解决问题。

然后问题又来了，当x取1或者0时，mid会等于0，x除以0直接报错。*（第二次提交：执行错误）*

只要在程序前面写了个针对0和1的特殊处理，虽然很丑，但终于能通过了。*（第三次提交：通过）*

**这样其实是不够的，我还是需要借助评论区/题解区大佬+提交不通过返回的信息才能做出这道题……但是没关系，开始阶段，先把题做出来就好，等二分查找的题做了一定量之后，再来总结分析，先量变，再质变。**

2022.01.29





#### [374. 猜数字大小 - 独立](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

猜数字游戏的规则如下：

- 每轮游戏，我都会从 **1** 到 ***n*** 随机选择一个数字。 请你猜选出的是哪个数字。
- 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。

你可以通过调用一个预先定义好的接口 `int guess(int num)` 来获取猜测结果，返回值一共有 3 种可能的情况（`-1`，`1` 或 `0`）：

- -1：我选出的数字比你猜的数字小 `pick < num`
- 1：我选出的数字比你猜的数字大 `pick > num`
- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！`pick == num`

返回我选出的数字。

> **示例 1：**
>
> ```
> 输入：n = 10, pick = 6
> 输出：6
> ```
>
> **提示：**
>
> - `1 <= n <= 231 - 1`
> - `1 <= pick <= n`

直接套模板1即可，而且这题在while中必然能找到答案，根本走不到退出while循环那一步。

这是二分专题里第一道我能独立做出来的题。。。

2022.02.03

#### [33. 搜索旋转排序数组 - 中等](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

> **示例 1：**
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 5000`
> - `-10^4 <= nums[i] <= 10^4`
> - `nums` 中的每个值都 **独一无二**
> - 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
> - `-10^4 <= target <= 10^4`
>
> **进阶：**你可以设计一个时间复杂度为 `O(log n)` 的解决方案吗？

暴力解法就是直接遍历，时间O(N)，但我们的目标（面试官的要求）是O(logN)的时间复杂度。

这题我直接不会。。。还是看了官方题解。

解题思想：二分查找，只能对排序数组做，这题整个数组是部分有序，那就用二分切割成两个区间，其中一个区间肯定是单调递增的（为什么？因为转折点要么在左边区间，要么在右边区间），这样我们就可以针对那个单调递增的区间做处理。如果要找的值不在单调递增区间内，那么下一轮就对【部分有序】的区间进行切割。

说得容易，但是小细节实在是太多了……我看了题解，然后自己去写，提交了4次才过……

2022.02.03

## LeetBook 二分查找模板2

#### 模板2

模板2是二分查找的高级模板。它用于查找需要访问数组中当前索引及其直接右邻居索引的元素或条件。

```java
int binarySearch(int[] nums, int target){
    if(nums == null || nums.length == 0) {
        return -1;   
    }

    int left = 0;
    int right = nums.length;
    while(left < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid;
        }
        else if(nums[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid;
        }
    }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.length && nums[left] == target) {
      return left;
  }
  return -1;
}
```

#### [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

>  
>
> **示例 1：**
>
> ```
> 输入：n = 5, bad = 4
> 输出：4
> 解释：
> 调用 isBadVersion(3) -> false 
> 调用 isBadVersion(5) -> true 
> 调用 isBadVersion(4) -> true
> 所以，4 是第一个错误的版本。
> ```
>
> **提示：**
>
> - `1 <= bad <= n <= 231 - 1`

由低效到高效开始说吧。

1. 暴力解：时间复杂度O(N)，在在一个n非常大的用例上直接超时。
2. 二分模板一：时间复杂度O(logN)，但是要15ms  22%
3. 二分模板二：时间复杂度O(logN)，但是11ms  99%

这题也是看题解才做出来的。能AC，但是我还是没有掌握“从无到有”想出解法的思路，没有掌握精髓。

2022.02.03





#### [162. 寻找峰值 - 中等](https://leetcode-cn.com/problems/find-peak-element/)

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

**你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。**

> **示例 1：**
>
> ```
> 输入：nums = [1,2,3,1]
> 输出：2
> 解释：3 是峰值元素，你的函数应该返回其索引 2。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,1,3,5,6,4]
> 输出：1 或 5 
> 解释：你的函数可以返回索引 1，其峰值元素为 2；
>      或者返回索引 5， 其峰值元素为 6。
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 1000`
> - `-2^31 <= nums[i] <= 2^31 - 1`
> - 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`——无重复元素

暴力解就不提了，面试官不会满意的。

要用二分。

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            }
            else {  //else if(nums[mid] > nums[mid + 1])
                right = mid;
            }
        }
        return left;    //return right;
    }
}
```

可以称之为“爬坡法”，核心思想是：一直往高处走，一定能走到峰顶。

先确定一个点mid，

* 如果是mid < mid + 1，那么mid往右到mid + 1是上坡，[mid + 1, right]区间内一定有峰顶，大不了走到右边界；
* 如果是mid > mid + 1，那么mid往右到mid + 1是下坡（往左走就相当于上坡），[left, mid]区间内一定峰顶，大不了走到左边界。
* 当[left, right]区间内只有一个数，即left == right时退出循环并返回left

解法我懂了，但自己写出来还是不行，玄学。。

精品题解&完整证明：[【宫水三叶の相信科学系列】关于能够「二分」的两点证明 - 寻找峰值 - 力扣（LeetCode）](https://leetcode-cn.com/problems/find-peak-element/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-qva7v/)

2022.02.04

#### [153. 寻找旋转排序数组中的最小值 - 中等](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

> **示例 1：**
>
> ```
> 输入：nums = [3,4,5,1,2]
> 输出：1
> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
> ```
>
> **提示：**
>
> - `n == nums.length`
> - `1 <= n <= 5000`
> - `-5000 <= nums[i] <= 5000`
> - `nums` 中的所有整数 **互不相同**
> - `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

我TM写了两个多小时，提交了四次，都没法用二分提交通过。。

细节是魔鬼。。。

2022.02.04





## ------------------

不做LeetBook的题了，都是中等题，但是我连二分最基础的用法都没有完全悟透，LeetBook剩下的内容不适合我。

还是做二分专题的简单题吧。

---

## LC 二分查找 - 简单

#### [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

> 示例 1：
>
> 输入：num = 16
> 输出：true
> 示例 2：
>
> 输入：num = 14
> 输出：false
>
>
> 提示：
>
> 1 <= num <= 2^31 - 1

**方法一：调用库函数**

**方法二：暴力遍历，时间复杂度O(N)**

**方法三：二分查找，时间复杂度为O(LogN)**

<u>第一次思路清晰地靠自己写出了二分查找AC！这次不是玄学编程了！</u>

主要是看了这篇文章被点通了：[代码随想录 - 704.二分查找](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#￦ﾀﾝ￨ﾷﾯ)

> ## 思路
>
> **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。
>
> 二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？
>
> 大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。
>
> 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

我TM直接悟了。

这题我选用[left, right]，定义为num的整数平方根（如果存在的话）的取值范围，那么循环条件自然是left <= right，如果退出循环，说明区间（取值范围）为空，说明找不到，返回false。

> 其实退出循环时，right的值刚好就是num的真正的平方根向下取整后的值，即Math.sqrt(num)。至于为什么？请看下一题的分析，举一反三。

然后为了避免mid * mid的溢出问题，可以用一个long型局部变量存mid * mid，也可以直接用num / mid的值与mid比较，不过后一种还要考虑5/2=2和4/2=2的问题，得再反过来试试mid * mid是否等于num，等于才能返回true，否则就得返回false。

上代码！（纪念我第一次写二分写得这么有底气）

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 1, right = num;
        //可取的正整数平方根位于[left, right]范围内，闭区间
        while(left <= right) {
            int mid = left + (right - left) / 2;
            //mid * mid < num，mid太小
            if(num / mid > mid) {
                left = mid + 1;
            }
            //mid * mid > num，mid太大
            else if(num / mid < mid) {
                right = mid - 1;
            }
            else {
                //num / mid == mid有两种情况，一个是刚好找到4/2=2，一个是刚好找不到5/2=2。
                //mid * mid不会超过num，不用担心溢出问题
                if(mid * mid == num) {
                    return true;
                }
                break;
            }
        }
        return false;
    }
}
```

**方法四：牛顿迭代，时间复杂度为O(LogN)**

这个我暂时还没学，比较复杂。

2022.02.05

#### 心得1：取值区间的设置

取值区间就是解的取值范围（区间），你可以设置为[left, right]闭区间，或[left, right)半开半闭区间等等。

**1-1 循环条件的选择**

循环条件是选择left < right还是left <= right还是left -1 < right？这取决于取值区间的设置。

只要明确了取值区间的设置，比如定义为[left, right]，闭区间，那么就肯定选择left <= right。

**1-2 怎么进行收缩操作**

如果已经知道mid不是解，且mid太大或太小，left或right怎么收缩？这取决于取值区间的设置。

只要使收缩后的left和right仍然满足取值区间的设置就好了。比如取值区间定义为[left,right)，那么排除mid后，right就可以收缩到mid；如果定义为[left,right)，那么排除mid后，right就应该收缩到mid-1。

进行收缩操作时，必须保证解仍然处于收缩后的取值区间之内，或者说收缩后的取值区间内必定有解，而不会错过解。

2022.02.05

#### [441. 排列硬币](https://leetcode-cn.com/problems/arranging-coins/)

你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。

> **示例 1：**
>
> ![img](二分查找-第一轮/arrangecoins1-grid.jpg)
>
> ```
> 输入：n = 5
> 输出：2
> 解释：因为第三行不完整，所以返回 2 。
> ```
> **提示：**
>
> - `1 <= n <= 2^31 - 1`

芜湖！第二道我自己思路清晰写出来的二分！中等题我唯唯诺诺，简单题我重拳出击。

假设有效阶梯行数（即可形成完整阶梯行的总行数）为k，硬币总数为n，那么这题可以根据等差数列前n项和的公式算出k与n的关系——如果k刚好，即不存在不完整阶梯行的话，<u>(1 + k) / 2 * k = n</u>。

设定k的取值区间是[left, right]，那么肯定用left <= right。

把mid当作k试一下是不是刚好满足这条公式，如果满足就直接返回；如果不满足，并且得出的值比硬币数n还大，说明太多行了，那就缩一下右边界；反之亦然。

当然，如果k刚好，那么一定能在循环中找到，非常容易理解；

如果k不刚好，也就是说存在不完整阶梯行，那么等到取值区间已经被缩减剩2个数的时候，因为左边界会觉得自己太小（或者右边界觉得自己太大），然后往右（往左）移，导致不满足left<=right，即right+1=left，退出循环。此时right就是我们要找的k。

上代码！（中等题我唯唯诺诺，简单题我重拳出击）

```java
class Solution {
    public int arrangeCoins(int n) {
        //根据等差数列前n项和公式：(A1 + An) / 2 * n = Sn
        //可得：(1 + k) / 2 * k = n，此处k为有效阶梯行，n为硬币总数
        int left = 1, right = n;
        //k解的取值范围：[left, right]
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if((long)(1 + mid) * mid / 2 == n) {
                return mid;
            }
            else if((long)(1 + mid) * mid / 2 > n) {
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }
        //本题必定有解，因此退出循环只有一种情况，就是存在不完整阶梯行，
        //此时要么是left认为自己应该稍大于k，因此走到k+1；要么是right认为自己应该稍小于k+1，因此走到k。
        //即right = k, left = k + 1，right即为解。
        return right;
    }
}
```

2022.02.05

#### [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'

> 示例：
>
> 输入:
> letters = ["c", "f", "j"]
> target = "a"
> 输出: "c"
>
> 输入:
> letters = ["c", "f", "j"]
> target = "c"
> 输出: "f"
>
> 输入:
> letters = ["c", "f", "j"]
> target = "d"
> 输出: "f"
>
> 输入:
> letters = ["c", "f", "j"]
> target = "g"
> 输出: "j"
>
> 输入:
> letters = ["c", "f", "j"]
> target = "j"
> 输出: "c"
>
> 输入:
> letters = ["c", "f", "j"]
> target = "k"
> 输出: "c"
>
>
> 提示：
>
> letters长度范围在[2, 10000]区间内。
> letters 仅由小写字母组成，最少包含两个不同的字母。
> 目标字母target 是一个小写字母。

二分简单题再下一城！这次举一反三，总结出三个心得！

思路如下：

取值区间设置为[left, right]，则循环条件选择left<=right。

这题要找到“比target大的最小字母”，那么核心if的条件是什么？比target大 && 最小字母，所以在判断letters[mid]是否满足时肯定还要比较letters[mid-1]。为了避免mid-1越界，应该先把第0个元素特殊处理，顺便把题目条件特别指出的另一种特殊情况处理掉（即target >= letters[length - 1]）。所以left可以从1开始，因为0已经被处理过了，这样mid-1就不可能越界；而right初始值依旧为length-1。

在程序一开始完成特殊处理后，我们可以就确定，[left, right]内必定有解。又由于这道题不可能出现“幽灵解”，所以必定能够在while循环内找到解，不可能退出循环。所以循环外的最后的return可以随便写。

初始值、循环条件、核心if的条件、循环后处理都搞定了，那么循环内的if-else逻辑怎么说？

如果[mid]不是解，即不满足第一个if，那只有两种可能

* 要么mid太小，导致[mid] <= target，那就收缩左区间；
* 要么mid太大，导致[mid - 1] > target，那就收缩右区间。

就这么简单！

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        //排除target比所有letter都小，或者所有letter都不比target大的情况
        if(letters[0] > target || letters[letters.length - 1] <= target) {
            return letters[0];
        }
        //已经排除“比target大的最小字母位于下标0”的情况，故取值区间从1开始，这样就可以避免[mid-1]越界。
        int left = 1, right = letters.length - 1;

        while(left <= right) {
            int mid = left + (right - left) / 2;
            //比target大 && 的最小字母
            if(letters[mid] > target && letters[mid - 1] <= target) {
                return letters[mid];
            }
            //不满足上一个if，要么是因为比target小或相等
            else if(letters[mid] <= target) {
                left = mid + 1;
            }
            //要么是因为[mid-1]同样比target大
            else {      //letters[mid - 1] > target
                right = mid - 1;
            }
        }
        //一开始就排除了无解的情况，所以循环内必定能找到解，不可能退出循环
        return '\0';
    }
}
```

2022.02.05

#### 心得2：幽灵解

**幽灵解**是指实际上**并不存在于现有数组中**的精确解。比如找平方根时，2的精确解是1.44......，**最终解**是1。

在二分查找中，如果一道题目可能出现幽灵解，就意味着程序不一定能够在取值区间内找到解，换句话说，不一定能够在while循环内找到解。因为程序只能根据数组中现有的元素去判断是否为解，而幽灵解并不存在于现有数组中，自然找不到。

但是找不到不代表无法正确地收缩取值区间，如果在某个测试用例中出现了幽灵解，则程序的左右边界必定会收缩成这样的情况“left跑到right的右一位”，因为幽灵解是抓不到的——它是个幽灵。

因此，**如果一道题目可能出现幽灵解，那就必须考虑退出循环后的返回值**；否则不需要考虑，随便返回什么都行，反正程序走不到那一步。

2022.02.05

#### 心得3：核心if的条件

我们已经知道，

* while循环的条件，要看取值区间的设置（心得1-1）；
* while循环内如何收缩，同样要看取值区间（心得1-2）；
* while循环退出后的操作，要看是否可能出现幽灵解（心得2）

但是，在考虑如何收缩之前，我们不禁要问：while循环内的if-else条件怎么写？

**首先要确定“mid为解的判断条件”，即核心if的条件**（while循环内的第一个if），确定核心if的条件之后，剩下的逻辑结构就呼之欲出了。

**然后想一想，如果mid进不了核心if，会有几种情况？这几种情况其实就意味着不同的收缩方向，即不同的else if、else的条件，而 else if、else内则是对应方向的收缩操作。**我们在进行收缩操作（进入else内）之前，当然要先确定收缩方向（进入else的条件）——要么是收缩right边界，要么是收缩left边界，至于具体的收缩操作这里就不展开了。

举个例子，比如你确定了核心if的条件是nums[mid] == target，mid满足就说明它是解，不满足就说明要进行收缩。那么如果此时mid不满足核心if的条件【==】，会有几种情况呢？情况1，【<】，那就应该收缩left；情况2，【>】，那就应该收缩right。这样我们就确定了收缩方向。

2022.02.05

---

以上3道简单题和3个心得，都是我在5号这天完成的。

虽然都是简单题，但却是我第一次摆脱了二分查找的”玄学编程“，整个做题过程中的思考逻辑都比较清晰。

Keep moving. 时间会告诉你答案。

---

