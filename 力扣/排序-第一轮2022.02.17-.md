# 排序-第一轮 刷题笔记

#### 回顾  数组*7+字符串\*2

排序第一轮开始之前，做别的标签（估计大多是**数组**标签）已经通过了这么多题：

<img src="排序-第一轮2022.02.17-/开始之前.png" alt="开始之前" style="zoom:67%;" />

那就简单回顾一下吧。

其实以下题目虽然都带“排序”标签，大多数都不适合用排序做，因为排序的时间复杂度最低也是O(N*logN)，太低效了。

##### （数组标签）[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

双指针从后向前填即可。

##### （数组标签）[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

要么排序后直接定位到数组中间（“管中之蛇”），

要么用摩尔投票法（“一超多强的人数优势”）。

> 数组标签的刷题笔记详细记录了这两种高效解法，但不知道为什么没有实现（当时AC用的是时间O(N)空间O(N)的哈希映射，算是暴力法）。
>
> 所以我就做了一下，提交了这两种解法。

##### （数组标签）[217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

可以用HashSet一个一个存，存不进去就是出现重复元素。但是哈希表底层的构建真的很慢。

也可以先用一次遍历找到数组中的最大值和最小值，然后在这个范围内构建数组映射，然后再遍历一次数组，出现过就记录一下，如果遇到已经有过记录的元素，说明出现了重复元素。这种方法和前一种的复杂度都相同，但实际速度快多了。

##### （字符串标签）[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

暴力思路就哈希映射，看到小写字母限制，第一反应用**数组映射**。

> 搞笑的是，字符串第一轮是在数组第一轮后面的，所以做这道题的时候的我早就总结过了数组映射——当时称为“差值表”——的用法，但当时却完全没想到这个思路，还在折腾哈希表，时间消耗十几ms（捂脸）。
>
> 所以这次我也用数组映射提交了一下。

##### (数组标签)[268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

区间内的数字总和，减去实际数组里的数字总和，就是丢失的那个数字。前者可以用**等差数列的前n项和公式**算出来，后者用一次直接遍历即可。

> 当时可能懒得用公式，毕竟就算直接在遍历中累加下标也是0ms，或者只是单纯的没想到可以用公式。
>
> 还是补一次提交吧。

##### (数组标签)[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

利用0 <= nums1[i], nums2[i] <= 1000的条件，可以用数组映射，记录nums1中哪些值出现过，然后在nums1中遍历，如果nums1中出现过，就加进交集，并把它**标记为未出现**，避免nums2中出现重复元素时往交集里添加重复数字的情况。

> 上一次我也是先想到数组映射，但是我写了很久，都没能解决nums2中也有重复元素的情况，只好改用HashSet，能自动去重。
>
> 这次重新做，重新提交，其中我大概只花了几秒钟就自然而然地解决了这个小问题，也算上“比昨天的自己厉害一点点”吧。

##### (数组标签)[350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

哈哈哈，和上一题没啥区别，就是把数组映射由boolean型改成int型，加进交集后，把“标记为未出现”改成“**标记出现次数减一**”，没错，就这么简单。

> Again……当时折腾了好几种解法，都没能达到0ms，而且当时我肯定是看了很多评论区和题解区的思路的，居然没看到一个执行用时beat 100%的解法？真想自己发个题解。
>
> 补一次提交。

##### (字符串标签)[389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

要么比对两个字符串的字符的ascii总值，要么用异或，算到最后剩下的就是多出来的那个字符。

> 因为两个字符串的长度只差1，因此两次遍历可以合为一次。
>
> 补一次提交。

##### (数组标签)[414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)

时间O(3N)的解法就是，三次遍历，第一次找最大，第二次找第二大，第三次找第三大，简单粗暴。

时间O(N)的解法是，同时维护三个变量代表前三榜单的数字，一次遍历，在遍历过程中不断更新前三榜单。由于nums[i]的取值范围完全覆盖了int型的取值范围，所以为了能够区分三个变量的初始值（最后需要确认是否存在第三大数字），应该改用long型存储，初始值设置为比Integer.MIN_VALUE更小就可以了。

2022.02.17





#### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

> 示例 1:
>
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> 示例 2:
>
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
>
>
> 提示：
>
> 1 <= g.length <= 3 * 104
> 0 <= s.length <= 3 * 104
> 1 <= g[i], s[j] <= 231 - 1

这题太经典了，就是那本《LeetCode 101 》的书的第一道题。

**最优解当然是：排序后双指针贪心算法。**

先做排序，然后维护双指针，从最小的孩子和最小的饼干开始查——为了满足更多孩子，肯定先看胃口小的孩子，而且如果可以的话，肯定要给孩子能够满足它胃口的最小饼干。

如果这块饼干够吃，计数就+1，孩子指针+1（已经吃了），饼干指针+1（已经被吃了）；

如果不够吃，饼干指针也+1（如果目前还没吃到饼干的孩子中，胃口最小的那个，都对这块饼干不满意，那这块饼干就不用了，反正剩下的孩子都是胃口更大的，更看不上这块饼干了）。

等到孩子查完或者饼干查完，就退出循环，返回计数值。

<img src="排序-第一轮2022.02.17-/455官方题解复杂度分析.png" alt="455官方题解复杂度分析" style="zoom: 80%;" />

2022.02.18