# 力扣刷题记录

## 刷题方法论

参考：

[大一计算机学生如何高效刷力扣？ - 知乎](https://www.zhihu.com/question/392882083)

怎么刷？

> @82DF-5C82：
>
> 如果学过算法和数据结构，那每天刷就行了。
>
> 第一遍以结果正确为目标，不追求运行效率，长时间没思路就看参考代码，遇到没学过的算法和数据结构就补一下。
>
> 第二遍以运行效率为目标，追求尽可能低的算法复杂度，同时加强记忆。
>
> 还有余力的话再刷第三第四遍，以熟练为目标，规定自己每题在有限的时间内AC。
>
> 最开始肯定会很吃力，慢慢地就好了。另外也要慢慢接触除了算法以外的知识体系以及工程实践，然后逐渐找到自己的方向，不要沉迷经典算法。

刷什么？

>  @代码随想录：
>
>  * 第一轮
>
>  题目类别推荐按照这个顺序来说： **数组 ->字符串 ->链表->二分查找->排序->哈希表-> 栈->队列 ->树 、递归、回溯 -> 堆** ，每一个类别只做简单的题目！而且是从通过率又高向低来刷。
>
>  这样刷过一遍之后 我们基础的数据结构和算法就已经差不多了
>
>  * 第二轮
>
>  开始做第一轮类别里面中等难度的题目
>
>  * 第三轮
>
>  这一轮的题目所代表的算法是比较难的，如果之前没有了解过，直接就刷题会很难，所以，建议把相关算法的理论看一遍，再去刷题， **先了解一下 什么是 拓扑排序、 分治，搜索树，贪心，动态规划，以及深搜和广搜**，然后再去刷题
>
>  推荐按照这个顺序去做：**拓扑排序->分治算法-> 二叉搜索树->贪心算法->动态规划-> 深度优先搜索 -> 广度优先搜索-->图->数学**
>
>  这里依然还是只做简单难度的题目 按照通过率又高向低
>
>  * 第四轮
>
>  开始尝试做第一轮里面的 困难难度的题目 （不强求，仅仅是尝试，面试中也不会太难）
>
>  同时开始做第二轮里面 中等难度的题目 （不用全都做，选一下自己一看就有想法的题目）
>
>  * 第五轮
>
>  然后开始做做leetcode分类里面 第一轮和第二轮都没有涉及到的类别的题目，相对于其他类型，面试中最常考察的是： **字典树-> 并查集 -> 树状数组->线段树 ， 这里只做简单难度的就可以了！**
>
>  剩余类型题目也凭个人喜好，选一些简单难度的题目做一做就可以了。

## 第1轮

### 数组 - 简单

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

这题简单，直接看官方题解即可。（我的两次AC的思路和官方题解差不多）

一个是暴力枚举，O(N*N)，O(1)，能AC但成绩很差；

一个是哈希表，这也是典型的**把数组遍历的两层遍历O(N*N)改为一层遍历O(N)的思路，就是存入哈希表**，这样查找的时间效率为O(1)，当然，会牺牲一定的空间。

还有值得注意的是，**“存入哈希表”最高效的方法是【边找边存】O(N)，而不是【存完再找】O(2N)**——后者是我第二次AC的思路，就是先遍历一遍存入全部元素，然后遍历一遍来找，同样能AC但成绩很差；前者是官方题解的，确实妙。
2021.11.01AC

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使每个元素**只出现一次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在**原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
>
>  示例 2：
>
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
>
> 提示：
>
> - `nums` 已按升序排列

注意三个条件：原地修改，空间O(1)，升序数组
我的AC思路其实就是官方题解中的双指针，preIndex相当于slow指针，i相当于fast指针，但我还记录了一个preNum，通过对比当前元素是否与上一个被加入的元素相同，来判断当前元素是否为新元素。但这是没有必要的（消耗空间），其实只需要比较一个元素是否和它的上一个元素不同就可以了。
至于官方题解的【快慢双指针】，再配合【判断是否与前一个元素相同来判断是否为重复元素】，真是太优雅了。

2021.11.02AC

#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 `nums` 和一个值 `val`，你需要**原地**移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2：
>
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

26题的增强版，不过26是要删除重复项，27是要删除特定项，此时只有两个条件：原地修改，空间O(1)。

不过照样可以用【快慢双指针】搞定，思路与26很相似。

2021.11.02AC

#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给定一个已按照 **非递减顺序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。
>
> 函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

既然是有序数组，那就要利用好“有序”这个性质，查找有序数组？那就是二分查找了。
但是一开始写二分查找我没写对（边界出了问题），后来用了LeetBook二分查找的模板1（后来发现官方题解1也是这个）才AC，但是只有36% 29%。*如果把这种成绩视为可以的话，那对这道题是一种浪费。*
看了官方题解2，没想到还有【左右双指针】这种时间效率O(N)的解法：把左指针放到最前，把右指针放到最后，计算两个指针对应元素之和，与target做比较，太大了要变小就让右指针往左挪，毕竟左指针已经最小了；太小了要变大就让左指针往右挪，毕竟右指针已经最大了。

那有没有可能错过？如果正确的下标是2和5，那么left有没有可能走到比2大的地方？right有没有可能走到比5小的地方？答案是：不可能。其实比较难理解的就在于“临界点”处。

假设left先走到了2，这时候right还太大，和也太大（left必须停下，不可能再右移），必须左移right，直至right走到5。同理，假设right先走到了5，这时候left还太小，和也太小（right必须停下，不可能再左移），必须右移left，直至left走到2。
2021.11.06AC

以上笔记为2021.11.07首次整理到markdown上

---

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
>  **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```

排序数组找目标值，时间复杂度O(log n)...就差直接把“二分查找”四个大字写出来了。

没关系，直接写即可。不得不说LeetBook给的二分模板真好用。

这个题目比普通二分就多了个条件：哪怕找不到，也要返回合适的插入位置。**结合代码和画图**可知，如果找不到，那么最后一轮一定是left/right/mid挤在同一位置，然后target > nums[mid]，然后left = mid + 1，接着left > right所以跳出循环。此时left所处位置就是插入位置。

这题很简单（也是因为我以前在力扣的另一进度做过），但是却有点感悟，那就是：**理解算法一定要多画图！**

2021.11.07