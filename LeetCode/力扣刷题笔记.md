# 力扣刷题记录

## 刷题方法论

参考：

[大一计算机学生如何高效刷力扣？ - 知乎](https://www.zhihu.com/question/392882083)

怎么刷？

> @82DF-5C82：
>
> 如果学过算法和数据结构，那每天刷就行了。
>
> 第一遍以结果正确为目标，不追求运行效率，长时间没思路就看参考代码，遇到没学过的算法和数据结构就补一下。
>
> 第二遍以运行效率为目标，追求尽可能低的算法复杂度，同时加强记忆。
>
> 还有余力的话再刷第三第四遍，以熟练为目标，规定自己每题在有限的时间内AC。
>
> 最开始肯定会很吃力，慢慢地就好了。另外也要慢慢接触除了算法以外的知识体系以及工程实践，然后逐渐找到自己的方向，不要沉迷经典算法。

刷什么？

>  @代码随想录：
>
>  * 第一轮
>
>  题目类别推荐按照这个顺序来说： **数组 ->字符串 ->链表->二分查找->排序->哈希表-> 栈->队列 ->树 、递归、回溯 -> 堆** ，每一个类别只做简单的题目！而且是从通过率又高向低来刷。
>
>  这样刷过一遍之后 我们基础的数据结构和算法就已经差不多了
>
>  * 第二轮
>
>  开始做第一轮类别里面中等难度的题目
>
>  * 第三轮
>
>  这一轮的题目所代表的算法是比较难的，如果之前没有了解过，直接就刷题会很难，所以，建议把相关算法的理论看一遍，再去刷题， **先了解一下 什么是 拓扑排序、 分治，搜索树，贪心，动态规划，以及深搜和广搜**，然后再去刷题
>
>  推荐按照这个顺序去做：**拓扑排序->分治算法-> 二叉搜索树->贪心算法->动态规划-> 深度优先搜索 -> 广度优先搜索-->图->数学**
>
>  这里依然还是只做简单难度的题目 按照通过率又高向低
>
>  * 第四轮
>
>  开始尝试做第一轮里面的 困难难度的题目 （不强求，仅仅是尝试，面试中也不会太难）
>
>  同时开始做第二轮里面 中等难度的题目 （不用全都做，选一下自己一看就有想法的题目）
>
>  * 第五轮
>
>  然后开始做做leetcode分类里面 第一轮和第二轮都没有涉及到的类别的题目，相对于其他类型，面试中最常考察的是： **字典树-> 并查集 -> 树状数组->线段树 ， 这里只做简单难度的就可以了！**
>
>  剩余类型题目也凭个人喜好，选一些简单难度的题目做一做就可以了。

## 刷题心态&意义

参考：

[为什么大家都贬低 LeetCode 的难度？ - 穷码农的回答 - 知乎](https://www.zhihu.com/question/348344092/answer/1613083757)

## 第1轮

### 数组 - 简单



#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

这题简单，直接看官方题解即可。（我的两次AC的思路和官方题解差不多）

一个是暴力枚举，O(N*N)，O(1)，能AC但成绩很差；

一个是哈希表，这也是典型的**把数组遍历的两层遍历O(N*N)改为一层遍历O(N)的思路，就是存入哈希表**，这样查找的时间效率为O(1)，当然，会牺牲一定的空间。

还有值得注意的是，**“存入哈希表”最高效的方法是【边找边存】O(N)，而不是【存完再找】O(2N)**——后者是我第二次AC的思路，就是先遍历一遍存入全部元素，然后遍历一遍来找，同样能AC但成绩很差；前者是官方题解的，确实妙。
2021.11.01AC



#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使每个元素**只出现一次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在**原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
>
>  示例 2：
>
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
>
> 提示：
>
> - `nums` 已按升序排列

注意三个条件：原地修改，空间O(1)，升序数组
我的AC思路其实就是官方题解中的双指针，preIndex相当于slow指针，i相当于fast指针，但我还记录了一个preNum，通过对比当前元素是否与上一个被加入的元素相同，来判断当前元素是否为新元素。但这是没有必要的（消耗空间），其实只需要比较一个元素是否和它的上一个元素不同就可以了。
至于官方题解的【快慢双指针】，再配合【判断是否与前一个元素相同来判断是否为重复元素】，真是太优雅了。

2021.11.02AC



#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 `nums` 和一个值 `val`，你需要**原地**移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2：
>
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

26题的增强版，不过26是要删除重复项，27是要删除特定项，此时只有两个条件：原地修改，空间O(1)。

不过照样可以用【快慢双指针】搞定，思路与26很相似。

2021.11.02AC



#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给定一个已按照 **非递减顺序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。
>
> 函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

既然是有序数组，那就要利用好“有序”这个性质，查找有序数组？那就是二分查找了。
但是一开始写二分查找我没写对（边界出了问题），后来用了LeetBook二分查找的模板1（后来发现官方题解1也是这个）才AC，但是只有36% 29%。*如果把这种成绩视为可以的话，那对这道题是一种浪费。*
看了官方题解2，没想到还有【左右双指针】这种时间效率O(N)的解法：把左指针放到最前，把右指针放到最后，计算两个指针对应元素之和，与target做比较，太大了要变小就让右指针往左挪，毕竟左指针已经最小了；太小了要变大就让左指针往右挪，毕竟右指针已经最大了。

那有没有可能错过？如果正确的下标是2和5，那么left有没有可能走到比2大的地方？right有没有可能走到比5小的地方？答案是：不可能。其实比较难理解的就在于“临界点”处。

假设left先走到了2，这时候right还太大，和也太大（left必须停下，不可能再右移），必须左移right，直至right走到5。同理，假设right先走到了5，这时候left还太小，和也太小（right必须停下，不可能再左移），必须右移left，直至left走到2。
2021.11.06AC

以上笔记为2021.11.07首次整理到markdown上

---



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
>  **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```

排序数组找目标值，时间复杂度O(log n)...就差直接把“二分查找”四个大字写出来了。

没关系，直接写即可。不得不说LeetBook给的二分模板真好用。

这个题目比普通二分就多了个条件：哪怕找不到，也要返回合适的插入位置。**结合代码和画图**可知，如果找不到，那么最后一轮一定是left/right/mid挤在同一位置，然后target > nums[mid]，然后left = mid + 1，接着left > right所以跳出循环。此时left所处位置就是插入位置。

这题很简单（也是因为我以前在力扣的另一进度做过），但是却有点感悟，那就是：**理解算法一定要多画图！**

2021.11.07



#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>
> **示例 1：**
>
> ```
> 输入：digits = [1,2,3]
> 输出：[1,2,4]
> 解释：输入数组表示数字 123。
> ```
>
> **提示：**
>
> - `1 <= digits.length <= 100`
> - `0 <= digits[i] <= 9`

直接在数组上求解即可，我的100% 80%AC思路是，从数组末尾开始遍历，

1. 如果当前数字是0~8，则直接+1返回原数组

2. 如果当前数字是9，则设为0，然后继续对下一位（i--）数字进行同样的判断，即进位——下一位数字要么+1，要么继续进位。（也可以写成递归）
3. 特殊情况，要是没有下一位，但仍需进位，也就是{9, 9, 9}的情况，就要作特殊处理一下，返回一个新数组。

看起来我的解法比较符合人类思维，其实就是模拟演算过程。

官方解法也很巧妙，它同样从数组末尾开始遍历，不过它是先找到第一个不为9的数字，让这个数字+1，然后这个数字右边的数字全部设置为0；如果所有数字都为9，那也很简单，特殊处理一下就好。

2021.11.08



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。
>
> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
>
> **注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> ```

一次过。

想要时间O(N)就用双指针。

想要空间O(1)就别用额外的数组，在原数组空间上改。

既然nums1后n位都是0，那就从后往前（从大往小）地遍历，用额外的指针记录待插入位置**nums1[j]**，用双指针找到nums1的待插入元素**nums1[i1]**和nums2的待插入元素**nums2[i2]**，再选择比较大的那个插入。

为什么while循环的循环条件是i2 >= 0？首先，既然是在num1的基础上合并nums1和nums2，nums2的元素全要搬到nums1，也就是说如果还没遍历完整个nums2，那肯定还没有完成合并；而遍历完整个nums2，也就标志着合并过程的结束。

为什么while循环条件不需要&& i1 >= 0？其实是需要的，不然i1--要是减成-1了，nums1[-1]就根本没法比较，所以在while循环体里的if-else条件中，先加一个i1 >= 0，万一i1真的不满足这个条件，就说明nums1原来的所有元素都已经搞定了，但显然nums2的还没有，所以就走else，插入nums2的元素。

为什么while循环条件不需要&& j >= 0？emmm，这个你自己算一下就知道。if-else任选一个都会移动双指针中的其中一个指针，i1从(m-1)到0最多m次，i2从(n-1)到0最多n次，哪怕i2没有提前走完（i2走完，循环体就结束），而是等i1先走完，那整个循环体最多也就走m+n次，而j从(m+n-1)到0最多也就m+n次，刚好。

2021.11.09



#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![1626927345-DZmfxB-PascalTriangleAnimated2.gif (260×240)](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>

题目上的gif图已经把本题的解法展示得清清楚楚了......这个提示太过了吧。

杨辉三角1太简单，顺便做一下杨辉三角2——

#### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

> 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: rowIndex = 3
> 输出: [1,3,3,1]
> ```

跑完杨辉三角1的代码，再返回对应row的List对象，就能AC，但是最优雅的解法肯定不是这样。没办法，看题解吧。

要获取第i行的元素，肯定需要第i-1行的；要获取i-1行的，肯定要获取i-2行的，那**O(N)**的时间复杂度是逃不过了，事实也确实如此（不考虑直接用杨辉三角的数学公式，仅仅用题目描述给的设定的话）。但空间复杂度呢？要一行一行地算，就必须一行一行地存吗？还真不少，我们可以在**“原地”修改List对象**！这样可以把空间复杂度从O(N)降到**O(1)**。

解法如下：

先手动存好第0行，然后从第1行开始遍历到第rowIndex行。

* 官方题解的方案：新行其实就是在上一行的List对象中先add一个0在末尾，元素个数就多了一个。然后从新行的第rowIndex个元素开始遍历到第1个元素（第0个元素一直为1，不用改动）。新行加的这个0的巧妙之处就在于我们这样遍历的时候，不用专门为新行的最后一个元素，即1，专门写一个add，而是可以和其他位置的元素一样，通过【上一行的第i个元素与第i-1个元素之和】来求值。

  我觉得这种写法实在没有必要，不如采用第二种。

* 另一种方案：新行先尾插入一个1（而不是0），然后从第rowIndex-1个元素开始遍历到第1个元素，或者正着遍历，都可以。这种写法比较符合正常逻辑。

2021.11.10



#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> **说明：**
>
> 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
>
> **示例 2:**
>
> ```
> 输入: [4,1,2,1,2]
> 输出: 4
> ```

我一开始的思路如下：

当你第一次遍历某元素时，你怎么知道这不是它出现的最后一次？答案是：没法知道。所以对于第一次出现的元素的处理一定是相同的，不用区别对待。要区别对待的是第二次遇到的元素，而这也是暴力解法AC的关键。

暴力解法，就是遍历，然后用HashSet存遇到的元素，hashset里没有就加入，有就删掉，最后剩下的就是那个只出现一次的数字。时间O(N)，空间O(N)，15% 9%，糟糕。

通过官方题解我还了解到其他**同水平**的解法，

* 用HashMap存每个元素的出现次数，最后用迭代器遍历哈希表找到出现次数为1的
* 用HashSet存所有元素，由于不可重复，所以HashSet里所有元素的总和的两倍减去原数组总和，就是要找的唯一数

但是！重点来了！有没有空间O(1)的解法？！有的，并且直接吊打以上解法，那就是：异或。

1. **Java中的异或运算符：`^`**

2. **运算法则：如果a、b两个数据对应的二进制位相同，则c的该位是0，否则是1。（异1或0）**

3. **推论：**
   1. **a^a=0（任何数和其自身做异或运算，结果是 00）**
   2. **a^0=a（任何数和 00 做异或运算，结果仍然是原来的数）**
   3. **如果a^b=c，那么a=b^c（异或运算满足交换律和结合律）**

这道题简直是为异或运算量身定做的！

直接遍历整个数组，从头异或到位，重复出现两次的，会变成0，0不影响别人；只出现1次的，遇到别的0也不会被影响。最终结果就是那个要求的数。

O(N) O(1)妙啊

2021.11.12



#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

> 给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
> **示例 2：**
>
> ```
> 输入：[2,2,1,1,1,2,2]
> 输出：2
> ```
>
> **进阶：**
>
> - 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

没有好的思路，那只好先暴力解AC掉（哈希表存元素出现个数），O(N) O(N)。成绩当然是很差，然后再看题解。

看了题解，发现这题解法很多。最关键的点在于，你要能够把“在数组中出现次数大于n/2”转换为**“元素个数超过其他元素个数之和”**。基于这点，就会有很多解法：

* 将数组排序，然后选数组中间的数，就是我们要找的多数元素。

  * 反证法：如果存在多数元素，但数组中间的数不是该多数元素，那么哪怕数组左边的所有元素都是同一元素，它也不是多数元素；数组右边的所有元素同理，因此当数组中间的数不是多数元素时，该数组不存在多数元素，这与前提相违背。
  * 形象法：管中有一条体长超过管长一半的蛇，往管的中间砍，必定会砍到蛇。

* 摩尔投票法：

  * 第一次看的厮杀向解释：

    > 假设不同数字相互抵消，那么最后剩下的数字，就是我们要找的多数元素。
    >
    > 我们可以把这个过程打个比方，比如现在多军对峙，假设阵营A士兵人数比其他方的人数都多，阵营A士兵能以一杀一，那么只要阵营A士兵不杀自己人（相同数字），去杀不同阵营的人（不同数字），那么最后剩下的那些士兵，就是阵营A的士兵。

  * 符合取名原意的投票向解释：

    在一次投票竞选中，已知存在一个支持者超过选民数量一半的热门候选人（但事先不知道是哪一位候选人），那么我们如果计算出投票结果，让票数最多的候选人当选？

    计算方法是将给热门候选人的投票和给其他候选人的投票“切磋”。

    1. 首先假设下一张选票的投票对象就是热门候选人，并记录下该候选人票数为1。
    2. 接下来遇到的选票如果是该候选人，那他的票数就加1；如果是其他候选人，那就互相抵消，他的票数就减1；如果减为0，就重复步骤1.
    3. 最后剩下的选票，一定是热门候选人的选票

2021.11.13



#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

> 给定一个整数数组，判断是否存在重复元素。
>
> 如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。 
>
> **示例 1:**
>
> ```
> 输入: [1,2,3,1]
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,2,3,4]
> 输出: false
> ```

这题我的思路是用HashSet存元素，存不进去的就是重复元素，提交成绩是5% 39%。

但是看了下题解，似乎也没有比这个思路更高明的题解，要么是排序后相邻比较，要么是直接用Set的轮子。**罢了，不纠结。**

*一件趣事：我原本把这个思路记为暴力解法，因为我看到题目马上就想到这种解了（下意识地觉得自己一下子想到的解法肯定是最低效的暴力解），结果看过评论之后想想，好像有人会想要用两个for循环来解诶（也许是刚开始刷力扣的我），那样就说明我有了一点小进步吧。*

---

2021.11.15补充【217. 存在重复元素】

后来去翻了下冷门的题解，终于发现一个能99% 15%的思路。

其实很好理解，和哈希表的思想是一样的，记录每个数字的出现个数。但是它用到的数据结构很有意思：

我们声明一个`int[] count`，数组长度`length`为原数组中最大值与最小值之差加一（当然要先遍历一次找到最大最小值），表示原数组若不考虑重复元素，最多只有`length`个数字。

然后，哈希表是用哈希算法来将特定元素映射到特定的存储位置，而我们用的映射算法很简单，遍历原数组，将特定数字减去最小值，得到的结果就是该数字在`count`中的下标。`count`是记录数字的出现次数的，既然能以O(1)时间查到特定数字的出现次数，那剩下的就水到渠成了吧。

同样是O(N) O(N)，这种解法的速度还是挺快的，而哈希表作为一个成熟的集合框架需要考虑很多其他的东西（但不是解这道题所需要的），可能就因为这个，速度没这种解法快；当然，由于`count`数组的长度是根据“原数组从最大值到最小值之间的每一个整数都出现“这个前提来设计的，所以很可能有空间的浪费，导致内存消耗比较大。

---

2021.11.21补充【217. 存在重复元素】

我把上面这种数据结构叫做“差值表”

#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

> 给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的 **绝对值** 至多为 *k*。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,1], k = 3
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1,0,1,1], k = 1
> 输出: true
> ```
>
> **示例 3:**
>
> ```
> 输入: nums = [1,2,3,1,2,3], k = 2
> 输出: false
> ```

1. 暴力解，遍历每个元素，然后在以该元素为中心，以k为半径的去心邻域里找到重复相同数字。（对于最开始的k个数字和最后面的k个数字，可能需要特殊处理，因为他的邻域只有一边）。时间O(N*N)，空间O(1)

2. 哈希表，记录【最近】出现位置，找到重复数字后判断下标差是否小于等于k。为什么不是记录【首次】出现位置？看示例2就懂了。

   时间O(N)，空间O(N)

3. 维护一个额外的数组index，记录元素原来的位置。然后对nums进行排序，index也跟着变化。最后再从有序数组中找到相同元素并比较他们原来的坐标。复杂度我都不想算了，麻烦！而且这不就是第二种思路吗！

我提交了第二种，结果居然90% 94%，一看官方题解，说第一种思路会超时。**罢了，不纠结。**

*因为在等某人回学校的时候，坐在行政楼前的石凳子上用手机看了两道题，所以这天就多做了两道。*

#### [228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

> 给定一个无重复元素的有序整数数组 `nums` 。
> 返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。
>
> 列表中的每个区间范围 `[a,b]` 应该按如下格式输出：
>
> - `"a->b"` ，如果 `a != b`
> - `"a"` ，如果 `a == b`
>
> 示例 2：
>
> 输入：nums = [0,2,3,4,6,8,9]
> 输出：["0","2->4","6","8->9"]
> 解释：区间范围是：
> [0,0] --> "0"
> [2,4] --> "2->4"
> [6,6] --> "6"
> [8,9] --> "8->9"
>
> 提示：
>
> 0 <= nums.length <= 20
> -231 <= nums[i] <= 231 - 1
> nums 中的所有值都 互不相同
> nums 按升序排列

其实看懂了题意，这道题的思路也就出来了：遍历，遇到相邻元素之差超过1的地方，就是旧区间的结束和新区间的开始。

但其实真正写的时候，还挺麻烦的，因为有几个重要的小细节：

1. 既然是比较相邻元素，那遍历到最后一个元素的时候该怎么办？肯定是不能从0到length-1的，这里我用的是当前元素与前一个元素比较，所以就从1到length-1，**避免数组越界**问题。用这种方式还有一个好处就是，当旧区间结束于前一个元素时，当前元素正好位于新区间的第一位。

2. 最后一位元素还有一个问题，哪怕是当前元素与前一位元素比较，要找到区间在哪结束，下标还是得继续加。但是最后一位元素的下标已经没得加了，所以还要针对这个问题，单独写一个if判断是不是到末尾了，如果是就把区间的右边界定在当前元素（即末尾元素），然后跳出循环。由于默认情况下一个区间的开始和结束下标是相同的，所以如果没有做这个**到达末尾**的判断，那么输出的最后一个区间（错误）一定只包含最后一个区间（正确的）的第一个元素。

3. 还有一个离奇的小细节，就是题目提醒里的`-2^31 <= nums[i] <= 2^31 - 1`。

   最大的int减最小的int会得到什么？（其实别说减最小的int，但凡是减一个负数，它们的差都会变成负数）

   看这个测试用例**[-2147483648,2147483647]**，num[0]-num[1] == -1！所以如果按“相邻元素之差超过1”写if，是无法处理这种特殊情况的，应该改成“**相邻元素之差不等于1**”

4. 以上两点，都是实际敲代码过程中可以发现和解决的，但是，当我AC之后发现成绩只有44% 48%，看了评论区一个100%的，发觉人家跟我思路类似？？**最关键的地方来了，频繁拼接字符串的地方，用StringBuilder或StringBuffer，不要用String直接拼接！**

   我用第一次AC的代码，把String改为StringBuilder，直接100% 95%！

2021.11.14AC



#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
>
> 示例 1：
>
> 输入：nums = [3,0,1]
> 输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
>
> 提示：
>
> n == nums.length
> 1 <= n <= 104
> 0 <= nums[i] <= n
> nums 中的所有数字都 独一无二
>
>
> 进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
>

数组的题，好像已经刷出一点感觉了。

几个麻烦的思路就一笔带过吧：要么先排序，要么哈希表。但都不够高效。咋办？

根据题目特点，数组里的数字都独一无二，题目“丢失的数字”——找丢失的数字......那就把数组所有数字加起来，再算一下本来这个范围所有数字加起来的总和，减去前者就得到丢失的数字了！

第一次AC时间100%但内存10%，原来是用了**foreach遍历数组——以后简单的数组遍历不要用这个，比较消耗内存**。改掉foreach。就100% 50%了！

从看题到写完题解，用时半小时——这才对嘛！

2021.11.17

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **示例:**
>
> ```
> 输入: [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **说明**:
>
> 1. 必须在原数组上操作，不能拷贝额外的数组。
> 2. 尽量减少操作次数。

折腾了一小时，修修改改才A...我还真的是在原数组操作的，也实现了O(N)的时间复杂度，但是6% 16...那个算法里面写太多判断了。具体可以去看原来的提交记录，我把程序注释写得很详细。但是这里不说这个算法，为啥？因为它复杂又低效。

简洁高效的解法：

把所有非0元素往前推（无需交换），然后把剩下的位置用0补上。

其实就相当于把原数组当成新数组来用，但是这种操作并不影响非0元素的相对顺序。妙啊！

*自己AC一小时，评论区大悟1分钟*

2021.11.18



#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

> 给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。
>
> 实现 NumArray 类：
>
> NumArray(int[] nums) 使用数组 nums 初始化对象
> int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）
>
>
> 示例：
>
> 输入：
> ["NumArray", "sumRange", "sumRange", "sumRange"]
> [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
> 输出：
> [null, 1, -1, -3]解释：
> NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
> numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
> numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
> numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
>
> 提示：
>
> 0 <= nums.length <= 104
> -105 <= nums[i] <= 105
> 0 <= i <= j < nums.length
> 最多调用 10^4 次 sumRange 方法

这题要通过实在太简单，一个学会Java的语法就能写出来。就直接暴力解嘛，10% 80%，空间复杂度还不错，但是每次查询都要O(N)时间——请注意“提示”的最后一行：**最多调用 10^4 次 sumRange 方法**，多次调用同一方法，如何优化？（需要具体题具体分析，如果题目没有“大量调用同一方法”这个条件，那么暴力解即最优解，没什么好优化的。）

了解一下**前缀和**。这种解法可能我见过之后就不会忘了（哭笑脸）

就是用O(N)时间初始化一个前缀和数组，长度比原数组多一位。

前缀和数组的第[i+1]项对应原数组的【第[i]项】与【第[i]项之前所有元素】之和。或许你可以理解为**原数组的前i项和**

这样在查找的时候，只需要O(1)时间，查找前缀和，一行return代码解决。妙啊！

2021.11.19



#### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> 示例 2：
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
>
>
> 说明：
>
> 输出结果中的每个元素一定是唯一的。
> 我们可以不考虑输出结果的顺序。

首先，数组是无序的，并且都要去重。一开始我想自己写【差值表】（第一次见是在【217.题 存在重复元素】），后来发现，不仅第一个数组有重复的，第二个数组也有，就卡了，然后改用【两个HashSet】，直接AC，90% 50%。后来我又对差值表做了两种小改动，也A了，100 20%左右。空间消耗确实很大，但是是真的快！和哈希算法计算哈希值相比，这个计算存储下标只需要一次减法运算...真是快到极致。

简单说一下两种思路吧，都挺好理解的。

1. 两个HashSet

   hashSet1存num1的元素。当然，会自动去重。

   然后看num2中的元素是否存在hashSet1中，如果存在，就加入hashSet2。当然，也会自动去重。

   最后用迭代器把hashSet2转换为数组返回即可。

2. 关于差值表的思想，在【217.题 存在重复元素】中已经详细记录了，这里不赘述。

   先构造一个boolean型差值表，然后遍历num1，记录num1中每个元素是否存在。当然，差值表和HashSet、HashMap那一派类似，也会去重。

   然后遍历num2，若差值表中该元素存在，则添加进结果数组中，并把差值表中该元素设为false，以避免num2中再次出现该元素——又一层去重。（这里的去重有另一种方法，就是改用int型差值表，记录出现次数。原理相似，不赘述）

   “添加进结果数组”？再声明一个数组吗？不行，长度不确定。再声明一个集合吗？不行，太消耗时间空间。就用原来的num1吧，把结果从头开始添加进num1，并记录结果数组的应有的长度，最后再根据这个长度new一个结果数组，然后复制过去就好。

p.s.你问我为什么不找找双百解法？我还真找不到，题解那里一大堆用时上了90%就拿出来发，也没考虑内存消耗成绩才50%。

2021.11.21



已经做18，还差2就换标签