# 力扣刷题记录

## <a id = "刷题方法论">刷题方法论</a>

#### 关于“库函数解题”

> 先说一说题外话：
>
> 对于这道题目一些同学直接用C++里的一个库函数 reverse，调一下直接完事了， 相信每一门编程语言都有这样的库函数。
>
> 如果这么做题的话，这样大家不会清楚反转字符串的实现原理了。
>
> 但是也不是说库函数就不能用，是要分场景的。
>
> 如果在现场面试中，我们什么时候使用库函数，什么时候不要用库函数呢？
>
> **如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。**
>
> 毕竟面试官一定不是考察你对库函数的熟悉程度， 如果使用python和java 的同学更需要注意这一点，因为python、java提供的库函数十分丰富。
>
> **如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**
>
> 建议大家平时在leetcode上练习算法的时候本着这样的原则去练习，这样才有助于我们对算法的理解。
>
> 不要沉迷于使用库函数一行代码解决题目之类的技巧，不是说这些技巧不好，而是说这些技巧可以用来娱乐一下。
>
> 真正自己写的时候，要保证理解可以实现是相应的功能。
>
> *2022.01.08引用自[344. 反转字符串 - 力扣（LeetCode） - 评论区@代码随想录](https://leetcode-cn.com/problems/reverse-string/comments/)*

#### 怎么刷？

> 如果学过算法和数据结构，那每天刷就行了。
>
> 第一遍以结果正确为目标，不追求运行效率，长时间没思路就看参考代码，遇到没学过的算法和数据结构就补一下。
>
> 第二遍以运行效率为目标，追求尽可能低的算法复杂度，同时加强记忆。
>
> 还有余力的话再刷第三第四遍，以熟练为目标，规定自己每题在有限的时间内AC。
>
> 最开始肯定会很吃力，慢慢地就好了。另外也要慢慢接触除了算法以外的知识体系以及工程实践，然后逐渐找到自己的方向，不要沉迷经典算法。
>
> *引用自[大一计算机学生如何高效刷力扣？ - 82DF-5C82的回答 - 知乎](https://www.zhihu.com/question/392882083/answer/1203775996)*

#### 刷什么？

>  * 第一轮
>
>  题目类别推荐按照这个顺序来说： **数组 ->字符串 ->链表->二分查找->排序->哈希表-> 栈->队列 ->树 、递归、回溯 -> 堆** ，每一个类别只做简单的题目！而且是从通过率又高向低来刷。
>
>  这样刷过一遍之后 我们基础的数据结构和算法就已经差不多了
>
>  * 第二轮
>
>  开始做第一轮类别里面中等难度的题目
>
>  * 第三轮
>
>  这一轮的题目所代表的算法是比较难的，如果之前没有了解过，直接就刷题会很难，所以，建议把相关算法的理论看一遍，再去刷题， **先了解一下 什么是 拓扑排序、 分治，搜索树，贪心，动态规划，以及深搜和广搜**，然后再去刷题
>
>  推荐按照这个顺序去做：**拓扑排序->分治算法-> 二叉搜索树->贪心算法->动态规划-> 深度优先搜索 -> 广度优先搜索-->图->数学**
>
>  这里依然还是只做简单难度的题目 按照通过率又高向低
>
>  * 第四轮
>
>  开始尝试做第一轮里面的 困难难度的题目 （不强求，仅仅是尝试，面试中也不会太难）
>
>  同时开始做第二轮里面 中等难度的题目 （不用全都做，选一下自己一看就有想法的题目）
>
>  * 第五轮
>
>  然后开始做做leetcode分类里面 第一轮和第二轮都没有涉及到的类别的题目，相对于其他类型，面试中最常考察的是： **字典树-> 并查集 -> 树状数组->线段树 ， 这里只做简单难度的就可以了！**
>
>  剩余类型题目也凭个人喜好，选一些简单难度的题目做一做就可以了。
>
>  *引用自[大一计算机学生如何高效刷力扣？ - 代码随想录的回答 - 知乎](https://www.zhihu.com/question/392882083/answer/1860538172)*

## 刷题心态&意义

*搬运自[为什么大家都贬低 LeetCode 的难度？ - 穷码农的回答 - 知乎](https://www.zhihu.com/question/348344092/answer/1613083757)*

> 有时候感觉，人和人之间的差异，真的是太大了。就在这同一个LeetCode话题下，这里说大家都贬低LC难度，但我也看到不少人在怀疑智商，我明显属于后者。只能膜拜前者，因为我也好羡慕那些拿offer拿到手软，从而通过compete拿到大包走上人生巅峰的大牛们。
>
> 那些贬低LC的人，肯定是编程底子好，打竞赛也能拿各种牌的吧。他们来刷LC，那自然不在话下，要不然，估计也拿不到金牌吧。牛人终归是牛人，他们打通了竞赛通道，说LC简单也是理所应当的。
>
> 但大部分人，包括我，刷LC几百题才觉得勉强有点入门，看到题目才不会那么犯怵。其实大部分时候，哪怕刷了几百题，遇到新题还是一样没思路。去打LC的周赛，估计还是只能做出来前两题，四题都解出来也是很不容易的。你看看前十的那些大牛们，一个题目只需要几分钟，他们说LC简单，那就是无法可说的，人家那都是约等于秒了这些题目。不服不行。
>
> 可是大家也别忘了LeetCode的初衷！LC是为了大家为面试做准备的，而不是一个纯粹的算法竞赛网站。
>
> 在我看来，LeetCode确实不容易，但更难的其实不仅仅是写出来代码那么简单，更难的地方在于**如何在拿到一个题目的时候，三五分钟就需要理解题目并有比较清晰的解题思路，这还是要在和面试官不断沟通的情况下。**
>
> 之后就需要和面试官边交流边写完整个的代码。过程中确保代码是正确的，而且需要跑测试代码说服面试官。这个过程我觉得很难，平时练习中，这也是大家最容易忽略的。尤其是口语交流还不是很理想的同学，这个地方需要刻意练习才行。你要是不能清晰表达自己的思路，面试官都不会让你动笔写代码。
>
> **如何将自己思路清晰地和面试官交流出来，并把代码写对，这才是我们最应该在平时练习中注意到的地方！**
>
> **能做到这一点的小伙伴，估计拿到offer的概率是不低的。而这，应该是大部分人练习LC的目的，至于别人贬低不贬低，又有什么影响呢？**
>
> **反正如果你在美国的话，大公司面试基本的题目就类似于leetcode的难度，很多公司甚至题目就来自于LeetCode。**
>
> 因此，真正想要找工作上岸的同学，你甚至都不需要去在意别人怎么说，你需要的是给自己一个好的刷题计划，按部就班刷4到5百题，不断总结提高。最好是在这个过程中，边刷题边投简历，以面试代练。这样一样，你就知道自己到底是题目做不出来，还是交流不畅。然后找到自己的弱点，不断进步，最终找到工作。
>
> **等找到了工作，拿到不错的包裹，你还会去和人争论LeetCode的难度几何么？**
>
> **不用刷完LeetCode, 也比较难刷完，毕竟没那么多时间和精力，而且需要高效有目标地刷：**
>
> [LeetCode按照怎样的顺序来刷题比较好？](https://www.zhihu.com/question/36738189/answer/908664455)
>
> **Go get the job offer，fxxxk the others.**
>
> 发布于 2020-12-06 10:19

## 第2轮

### 数组第2轮 - 简单*20

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

这题简单，直接看官方题解即可。（我的两次AC的思路和官方题解差不多）

一个是暴力枚举，O(N*N)，O(1)，能AC但成绩很差；

一个是哈希表，这也是典型的**把数组遍历的两层遍历O(N*N)改为一层遍历O(N)的思路，就是存入哈希表**，这样查找的时间效率为O(1)，当然，会牺牲一定的空间。

还有值得注意的是，**“存入哈希表”最高效的方法是【边找边存】O(N)，而不是【存完再找】O(2N)**——后者是我第二次AC的思路，就是先遍历一遍存入全部元素，然后遍历一遍来找，同样能AC但成绩很差；前者是官方题解的，确实妙。
2021.11.01AC



#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使每个元素**只出现一次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在**原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
>
>  示例 2：
>
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
>
> 提示：
>
> - `nums` 已按升序排列

注意三个条件：原地修改，空间O(1)，升序数组
我的AC思路其实就是官方题解中的双指针，preIndex相当于slow指针，i相当于fast指针，但我还记录了一个preNum，通过对比当前元素是否与上一个被加入的元素相同，来判断当前元素是否为新元素。但这是没有必要的（消耗空间），其实只需要比较一个元素是否和它的上一个元素不同就可以了。
至于官方题解的【快慢双指针】，再配合【判断是否与前一个元素相同来判断是否为重复元素】，真是太优雅了。

2021.11.02AC



#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 `nums` 和一个值 `val`，你需要**原地**移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2：
>
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

26题的增强版，不过26是要删除重复项，27是要删除特定项，此时只有两个条件：原地修改，空间O(1)。

不过照样可以用【快慢双指针】搞定，思路与26很相似。

2021.11.02AC



#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给定一个已按照 **非递减顺序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。
>
> 函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

既然是有序数组，那就要利用好“有序”这个性质，查找有序数组？那就是二分查找了。
但是一开始写二分查找我没写对（边界出了问题），后来用了LeetBook二分查找的模板1（后来发现官方题解1也是这个）才AC，但是只有36% 29%。*如果把这种成绩视为可以的话，那对这道题是一种浪费。*
看了官方题解2，没想到还有【左右双指针】这种时间效率O(N)的解法：把左指针放到最前，把右指针放到最后，计算两个指针对应元素之和，与target做比较，太大了要变小就让右指针往左挪，毕竟左指针已经最小了；太小了要变大就让左指针往右挪，毕竟右指针已经最大了。

那有没有可能错过？如果正确的下标是2和5，那么left有没有可能走到比2大的地方？right有没有可能走到比5小的地方？答案是：不可能。其实比较难理解的就在于“临界点”处。

假设left先走到了2，这时候right还太大，和也太大（left必须停下，不可能再右移），必须左移right，直至right走到5。同理，假设right先走到了5，这时候left还太小，和也太小（right必须停下，不可能再左移），必须右移left，直至left走到2。
2021.11.06AC

以上笔记为2021.11.07首次整理到markdown上

---



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
>  **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```

排序数组找目标值，时间复杂度O(log n)...就差直接把“二分查找”四个大字写出来了。

没关系，直接写即可。不得不说LeetBook给的二分模板真好用。

这个题目比普通二分就多了个条件：哪怕找不到，也要返回合适的插入位置。**结合代码和画图**可知，如果找不到，那么最后一轮一定是left/right/mid挤在同一位置，然后target > nums[mid]，然后left = mid + 1，接着left > right所以跳出循环。此时left所处位置就是插入位置。

这题很简单（也是因为我以前在力扣的另一进度做过），但是却有点感悟，那就是：**理解算法一定要多画图！**

2021.11.07



#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>
> **示例 1：**
>
> ```
> 输入：digits = [1,2,3]
> 输出：[1,2,4]
> 解释：输入数组表示数字 123。
> ```
>
> **提示：**
>
> - `1 <= digits.length <= 100`
> - `0 <= digits[i] <= 9`

直接在数组上求解即可，我的100% 80%AC思路是，从数组末尾开始遍历，

1. 如果当前数字是0~8，则直接+1返回原数组

2. 如果当前数字是9，则设为0，然后继续对下一位（i--）数字进行同样的判断，即进位——下一位数字要么+1，要么继续进位。（也可以写成递归）
3. 特殊情况，要是没有下一位，但仍需进位，也就是{9, 9, 9}的情况，就要作特殊处理一下，返回一个新数组。

看起来我的解法比较符合人类思维，其实就是模拟演算过程。

官方解法也很巧妙，它同样从数组末尾开始遍历，不过它是先找到第一个不为9的数字，让这个数字+1，然后这个数字右边的数字全部设置为0；如果所有数字都为9，那也很简单，特殊处理一下就好。

2021.11.08



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。
>
> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
>
> **注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> ```

一次过。

想要时间O(N)就用双指针。

想要空间O(1)就别用额外的数组，在原数组空间上改。

既然nums1后n位都是0，那就从后往前（从大往小）地遍历，用额外的指针记录待插入位置**nums1[j]**，用双指针找到nums1的待插入元素**nums1[i1]**和nums2的待插入元素**nums2[i2]**，再选择比较大的那个插入。

为什么while循环的循环条件是i2 >= 0？首先，既然是在num1的基础上合并nums1和nums2，nums2的元素全要搬到nums1，也就是说如果还没遍历完整个nums2，那肯定还没有完成合并；而遍历完整个nums2，也就标志着合并过程的结束。

为什么while循环条件不需要&& i1 >= 0？其实是需要的，不然i1--要是减成-1了，nums1[-1]就根本没法比较，所以在while循环体里的if-else条件中，先加一个i1 >= 0，万一i1真的不满足这个条件，就说明nums1原来的所有元素都已经搞定了，但显然nums2的还没有，所以就走else，插入nums2的元素。

为什么while循环条件不需要&& j >= 0？emmm，这个你自己算一下就知道。if-else任选一个都会移动双指针中的其中一个指针，i1从(m-1)到0最多m次，i2从(n-1)到0最多n次，哪怕i2没有提前走完（i2走完，循环体就结束），而是等i1先走完，那整个循环体最多也就走m+n次，而j从(m+n-1)到0最多也就m+n次，刚好。

2021.11.09



#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![1626927345-DZmfxB-PascalTriangleAnimated2.gif (260×240)](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>

题目上的gif图已经把本题的解法展示得清清楚楚了......这个提示太过了吧。

杨辉三角1太简单，顺便做一下杨辉三角2——

#### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

> 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: rowIndex = 3
> 输出: [1,3,3,1]
> ```

跑完杨辉三角1的代码，再返回对应row的List对象，就能AC，但是最优雅的解法肯定不是这样。没办法，看题解吧。

要获取第i行的元素，肯定需要第i-1行的；要获取i-1行的，肯定要获取i-2行的，那**O(N)**的时间复杂度是逃不过了，事实也确实如此（不考虑直接用杨辉三角的数学公式，仅仅用题目描述给的设定的话）。但空间复杂度呢？要一行一行地算，就必须一行一行地存吗？还真不少，我们可以在**“原地”修改List对象**！这样可以把空间复杂度从O(N)降到**O(1)**。

解法如下：

先手动存好第0行，然后从第1行开始遍历到第rowIndex行。

* 官方题解的方案：新行其实就是在上一行的List对象中先add一个0在末尾，元素个数就多了一个。然后从新行的第rowIndex个元素开始遍历到第1个元素（第0个元素一直为1，不用改动）。新行加的这个0的巧妙之处就在于我们这样遍历的时候，不用专门为新行的最后一个元素，即1，专门写一个add，而是可以和其他位置的元素一样，通过【上一行的第i个元素与第i-1个元素之和】来求值。

  我觉得这种写法实在没有必要，不如采用第二种。

* 另一种方案：新行先尾插入一个1（而不是0），然后从第rowIndex-1个元素开始遍历到第1个元素，或者正着遍历，都可以。这种写法比较符合正常逻辑。

2021.11.10



#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> **说明：**
>
> 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
>
> **示例 2:**
>
> ```
> 输入: [4,1,2,1,2]
> 输出: 4
> ```

我一开始的思路如下：

当你第一次遍历某元素时，你怎么知道这不是它出现的最后一次？答案是：没法知道。所以对于第一次出现的元素的处理一定是相同的，不用区别对待。要区别对待的是第二次遇到的元素，而这也是暴力解法AC的关键。

暴力解法，就是遍历，然后用HashSet存遇到的元素，hashset里没有就加入，有就删掉，最后剩下的就是那个只出现一次的数字。时间O(N)，空间O(N)，15% 9%，糟糕。

通过官方题解我还了解到其他**同水平**的解法，

* 用HashMap存每个元素的出现次数，最后用迭代器遍历哈希表找到出现次数为1的
* 用HashSet存所有元素，由于不可重复，所以HashSet里所有元素的总和的两倍减去原数组总和，就是要找的唯一数

但是！重点来了！有没有空间O(1)的解法？！有的，并且直接吊打以上解法，那就是：异或。

1. **Java中的异或运算符：`^`**

2. **运算法则：如果a、b两个数据对应的二进制位相同，则c的该位是0，否则是1。（异1或0）**

3. **推论：**
   1. **a^a=0（任何数和其自身做异或运算，结果是 00）**
   2. **a^0=a（任何数和 00 做异或运算，结果仍然是原来的数）**
   3. **如果a^b=c，那么a=b^c（异或运算满足交换律和结合律）**

这道题简直是为异或运算量身定做的！

直接遍历整个数组，从头异或到位，重复出现两次的，会变成0，0不影响别人；只出现1次的，遇到别的0也不会被影响。最终结果就是那个要求的数。

O(N) O(1)妙啊

2021.11.12



#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

> 给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
> **示例 2：**
>
> ```
> 输入：[2,2,1,1,1,2,2]
> 输出：2
> ```
>
> **进阶：**
>
> - 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

没有好的思路，那只好先暴力解AC掉（哈希表存元素出现个数），O(N) O(N)。成绩当然是很差，然后再看题解。

看了题解，发现这题解法很多。最关键的点在于，你要能够把“在数组中出现次数大于n/2”转换为**“元素个数超过其他元素个数之和”**。基于这点，就会有很多解法：

* 将数组排序，然后选数组中间的数，就是我们要找的多数元素。

  * 反证法：如果存在多数元素，但数组中间的数不是该多数元素，那么哪怕数组左边的所有元素都是同一元素，它也不是多数元素；数组右边的所有元素同理，因此当数组中间的数不是多数元素时，该数组不存在多数元素，这与前提相违背。
  * 形象法：管中有一条体长超过管长一半的蛇，往管的中间砍，必定会砍到蛇。

* 摩尔投票法：

  * 第一次看的厮杀向解释：

    > 假设不同数字相互抵消，那么最后剩下的数字，就是我们要找的多数元素。
    >
    > 我们可以把这个过程打个比方，比如现在多军对峙，假设阵营A士兵人数比其他方的人数都多，阵营A士兵能以一杀一，那么只要阵营A士兵不杀自己人（相同数字），去杀不同阵营的人（不同数字），那么最后剩下的那些士兵，就是阵营A的士兵。

  * 符合取名原意的投票向解释：

    在一次投票竞选中，已知存在一个支持者超过选民数量一半的热门候选人（但事先不知道是哪一位候选人），那么我们如果计算出投票结果，让票数最多的候选人当选？

    计算方法是将给热门候选人的投票和给其他候选人的投票“切磋”。

    1. 首先假设下一张选票的投票对象就是热门候选人，并记录下该候选人票数为1。
    2. 接下来遇到的选票如果是该候选人，那他的票数就加1；如果是其他候选人，那就互相抵消，他的票数就减1；如果减为0，就重复步骤1.
    3. 最后剩下的选票，一定是热门候选人的选票

2021.11.13



#### <a name="217">[217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)</a>

> 给定一个整数数组，判断是否存在重复元素。
>
> 如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。 
>
> **示例 1:**
>
> ```
> 输入: [1,2,3,1]
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,2,3,4]
> 输出: false
> ```

这题我的思路是用HashSet存元素，存不进去的就是重复元素，提交成绩是5% 39%。

但是看了下题解，似乎也没有比这个思路更高明的题解，要么是排序后相邻比较，要么是直接用Set的轮子。**罢了，不纠结。**

*一件趣事：我原本把这个思路记为暴力解法，因为我看到题目马上就想到这种解了（下意识地觉得自己一下子想到的解法肯定是最低效的暴力解），结果看过评论之后想想，好像有人会想要用两个for循环来解诶（也许是刚开始刷力扣的我），那样就说明我有了一点小进步吧。*

---

2021.11.15补充【217. 存在重复元素】

后来去翻了下冷门的题解，终于发现一个能99% 15%的思路。

其实很好理解，和哈希表的思想是一样的，记录每个数字的出现个数。但是它用到的数据结构很有意思：

我们声明一个`int[] count`，数组长度`length`为原数组中最大值与最小值之差加一（当然要先遍历一次找到最大最小值），表示原数组若不考虑重复元素，最多只有`length`个数字。

然后，哈希表是用哈希算法来将特定元素映射到特定的存储位置，而我们用的映射算法很简单，遍历原数组，将特定数字减去最小值，得到的结果就是该数字在`count`中的下标。`count`是记录数字的出现次数的，既然能以O(1)时间查到特定数字的出现次数，那剩下的就水到渠成了吧。

同样是O(N) O(N)，这种解法的速度还是挺快的，而哈希表作为一个成熟的集合框架需要考虑很多其他的东西（但不是解这道题所需要的），可能就因为这个，速度没这种解法快；当然，由于`count`数组的长度是根据“原数组从最大值到最小值之间的每一个整数都出现“这个前提来设计的，所以很可能有空间的浪费，导致内存消耗比较大。

---

2021.11.21补充【217. 存在重复元素】

我把上面这种数据结构叫做“差值表”

#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

> 给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的 **绝对值** 至多为 *k*。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,1], k = 3
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1,0,1,1], k = 1
> 输出: true
> ```
>
> **示例 3:**
>
> ```
> 输入: nums = [1,2,3,1,2,3], k = 2
> 输出: false
> ```

1. 暴力解，遍历每个元素，然后在以该元素为中心，以k为半径的去心邻域里找到重复相同数字。（对于最开始的k个数字和最后面的k个数字，可能需要特殊处理，因为他的邻域只有一边）。时间O(N*N)，空间O(1)

2. 哈希表，记录【最近】出现位置，找到重复数字后判断下标差是否小于等于k。为什么不是记录【首次】出现位置？看示例2就懂了。

   时间O(N)，空间O(N)

3. 维护一个额外的数组index，记录元素原来的位置。然后对nums进行排序，index也跟着变化。最后再从有序数组中找到相同元素并比较他们原来的坐标。复杂度我都不想算了，麻烦！而且这不就是第二种思路吗！

我提交了第二种，结果居然90% 94%，一看官方题解，说第一种思路会超时。**罢了，不纠结。**

*因为在等某人回学校的时候，坐在行政楼前的石凳子上用手机看了两道题，所以这天就多做了两道。*

#### [228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

> 给定一个无重复元素的有序整数数组 `nums` 。
> 返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。
>
> 列表中的每个区间范围 `[a,b]` 应该按如下格式输出：
>
> - `"a->b"` ，如果 `a != b`
> - `"a"` ，如果 `a == b`
>
> 示例 2：
>
> 输入：nums = [0,2,3,4,6,8,9]
> 输出：["0","2->4","6","8->9"]
> 解释：区间范围是：
> [0,0] --> "0"
> [2,4] --> "2->4"
> [6,6] --> "6"
> [8,9] --> "8->9"
>
> 提示：
>
> 0 <= nums.length <= 20
> -231 <= nums[i] <= 231 - 1
> nums 中的所有值都 互不相同
> nums 按升序排列

其实看懂了题意，这道题的思路也就出来了：遍历，遇到相邻元素之差超过1的地方，就是旧区间的结束和新区间的开始。

但其实真正写的时候，还挺麻烦的，因为有几个重要的小细节：

1. 既然是比较相邻元素，那遍历到最后一个元素的时候该怎么办？肯定是不能从0到length-1的，这里我用的是当前元素与前一个元素比较，所以就从1到length-1，**避免数组越界**问题。用这种方式还有一个好处就是，当旧区间结束于前一个元素时，当前元素正好位于新区间的第一位。

2. 最后一位元素还有一个问题，哪怕是当前元素与前一位元素比较，要找到区间在哪结束，下标还是得继续加。但是最后一位元素的下标已经没得加了，所以还要针对这个问题，单独写一个if判断是不是到末尾了，如果是就把区间的右边界定在当前元素（即末尾元素），然后跳出循环。由于默认情况下一个区间的开始和结束下标是相同的，所以如果没有做这个**到达末尾**的判断，那么输出的最后一个区间（错误）一定只包含最后一个区间（正确的）的第一个元素。

3. 还有一个离奇的小细节，就是题目提醒里的`-2^31 <= nums[i] <= 2^31 - 1`。

   最大的int减最小的int会得到什么？（其实别说减最小的int，但凡是减一个负数，它们的差都会变成负数）

   看这个测试用例**[-2147483648,2147483647]**，num[0]-num[1] == -1！所以如果按“相邻元素之差超过1”写if，是无法处理这种特殊情况的，应该改成“**相邻元素之差不等于1**”

4. 以上两点，都是实际敲代码过程中可以发现和解决的，但是，当我AC之后发现成绩只有44% 48%，看了评论区一个100%的，发觉人家跟我思路类似？？**最关键的地方来了，频繁拼接字符串的地方，用StringBuilder或StringBuffer，不要用String直接拼接！**

   我用第一次AC的代码，把String改为StringBuilder，直接100% 95%！

2021.11.14AC



#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
>
> 示例 1：
>
> 输入：nums = [3,0,1]
> 输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
>
> 提示：
>
> n == nums.length
> 1 <= n <= 104
> 0 <= nums[i] <= n
> nums 中的所有数字都 独一无二
>
>
> 进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
>

数组的题，好像已经刷出一点感觉了。

几个麻烦的思路就一笔带过吧：要么先排序，要么哈希表。但都不够高效。咋办？

根据题目特点，数组里的数字都独一无二，题目“丢失的数字”——找丢失的数字......那就把数组所有数字加起来，再算一下本来这个范围所有数字加起来的总和，减去前者就得到丢失的数字了！

第一次AC时间100%但内存10%，原来是用了**foreach遍历数组——以后简单的数组遍历不要用这个，比较消耗内存**。改掉foreach。就100% 50%了！

从看题到写完题解，用时半小时——这才对嘛！

2021.11.17

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **示例:**
>
> ```
> 输入: [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **说明**:
>
> 1. 必须在原数组上操作，不能拷贝额外的数组。
> 2. 尽量减少操作次数。

折腾了一小时，修修改改才A...我还真的是在原数组操作的，也实现了O(N)的时间复杂度，但是6% 16...那个算法里面写太多判断了。具体可以去看原来的提交记录，我把程序注释写得很详细。但是这里不说这个算法，为啥？因为它复杂又低效。

简洁高效的解法：

把所有非0元素往前推（无需交换），然后把剩下的位置用0补上。

其实就相当于把原数组当成新数组来用，但是这种操作并不影响非0元素的相对顺序。妙啊！

*自己AC一小时，评论区大悟1分钟*

2021.11.18



#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

> 给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。
>
> 实现 NumArray 类：
>
> NumArray(int[] nums) 使用数组 nums 初始化对象
> int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）
>
>
> 示例：
>
> 输入：
> ["NumArray", "sumRange", "sumRange", "sumRange"]
> [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
> 输出：
> [null, 1, -1, -3]解释：
> NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
> numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
> numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
> numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
>
> 提示：
>
> 0 <= nums.length <= 104
> -105 <= nums[i] <= 105
> 0 <= i <= j < nums.length
> 最多调用 10^4 次 sumRange 方法

这题要通过实在太简单，一个学会Java的语法就能写出来。就直接暴力解嘛，10% 80%，空间复杂度还不错，但是每次查询都要O(N)时间——请注意“提示”的最后一行：**最多调用 10^4 次 sumRange 方法**，多次调用同一方法，如何优化？（需要具体题具体分析，如果题目没有“大量调用同一方法”这个条件，那么暴力解即最优解，没什么好优化的。）

了解一下**前缀和**。这种解法可能我见过之后就不会忘了（哭笑脸）

就是用O(N)时间初始化一个前缀和数组，长度比原数组多一位。

前缀和数组的第[i+1]项对应原数组的【第[i]项】与【第[i]项之前所有元素】之和。或许你可以理解为**原数组的前i项和**

这样在查找的时候，只需要O(1)时间，查找前缀和，一行return代码解决。妙啊！

2021.11.19



#### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> 示例 2：
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
>
>
> 说明：
>
> 输出结果中的每个元素一定是唯一的。
> 我们可以不考虑输出结果的顺序。

首先，数组是无序的，并且都要去重。一开始我想自己写【差值表】（第一次见是在<a href="#217">【217.题 存在重复元素】</a>），后来发现，不仅第一个数组有重复的，第二个数组也有，就卡了，然后改用【两个HashSet】，直接AC，90% 50%。后来我又对差值表做了两种小改动，也A了，100 20%左右。空间消耗确实很大，但是是真的快！和哈希算法计算哈希值相比，这个计算存储下标只需要一次减法运算...真是快到极致。

简单说一下两种思路吧，都挺好理解的。

1. 两个HashSet

   hashSet1存num1的元素。当然，会自动去重。

   然后看num2中的元素是否存在hashSet1中，如果存在，就加入hashSet2。当然，也会自动去重。

   最后用迭代器把hashSet2转换为数组返回即可。

2. 关于差值表的思想，在【217.题 存在重复元素】中已经详细记录了，这里不赘述。

   先构造一个boolean型差值表，然后遍历num1，记录num1中每个元素是否存在。当然，差值表和HashSet、HashMap那一派类似，也会去重。

   然后遍历num2，若差值表中该元素存在，则添加进结果数组中，并把差值表中该元素设为false，以避免num2中再次出现该元素——又一层去重。（这里的去重有另一种方法，就是改用int型差值表，记录出现次数。原理相似，不赘述）

   “添加进结果数组”？再声明一个数组吗？不行，长度不确定。再声明一个集合吗？不行，太消耗时间空间。就用原来的num1吧，把结果从头开始添加进num1，并记录结果数组的应有的长度，最后再根据这个长度new一个结果数组，然后复制过去就好。

p.s.你问我为什么不找找双百解法？我还真找不到，题解那里一大堆用时上了90%就拿出来发，也没考虑内存消耗成绩才50%。

2021.11.21



#### [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2,2]
> 示例 2:
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[4,9]
>
>
> 说明：
>
> 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
> 我们可以不考虑输出结果的顺序。

一开始我想用两个HashMap暴力解（实在没什么好的思路），写了将近30分钟，还没通过（解答错误）——我知道再继续修修改改，最后肯定可以，但成绩也肯定很差。既然这不是比赛，而是练习，那就没必要花太多时间去继续“完善”这个低效的解法，所以我不再继续写，直接看题解——这是更高效的做法。

1. 其实官方题解的思路完全不复杂，和我自己的写法相比，就是多了一个点醒的思路。

   这道题的解法，用纯文字来说就是，记录较短那个数组中每一个数字的“出现次数”，然后再遍历另一个数组，如果数字相同，则抵消掉该数字的一次”出现次数“，并加入结果集；当然如果“出现次数”已经为0，就无法抵消。这种解法嘛，思想容易理解，成绩中等偏上，用时和内存消耗都在70%以上。

   具体的实现，你肯定会，但是，如果不提下面几点，也许你就不会用他去优化你的代码：

   * 查找hashmap中是否存在重复元素时，你还在用`if(hashmao.contains(xxx)) {hashmap.get(xxx);}`吗？

     直接用`getOrDefault();`就好，简洁。

   * 你还在手动复制特定长度的结果数组吗？

     直接用Arrays.copyOfRange(数组, start, end)

2. 评论区有一种解法能达到99% 10%

   先用Arrays.sort(xxx)给两个数组排序（说实话我不喜欢在做力扣题的时候用这种自动排序），然后声明三个指针，两个用来遍历两个数组，还有一个用来指向结果数组的下一个存储位置。为了省空间，结果数组用num1代替，最后Arrays.copyOfRange(num1, 0, 指针3)就好。

   具体遍历的时候是这样，两个升序数组都从头开始，nums1[i]和nums2[j]比较，如果前者小，则前者指针+1；如果后者小，则后者指针+1；如果两者相等，则两者指针都+1，并加入结果数组。直到遍历完任意一个数组就退出循环。

简单题都做到这份上了，这么说吧，我建议：

* **简单题，无论什么原因，20分钟内还没通过，就看题解！**
* **除非你对自己的算法有自信，认为它值得你花时间去完善（BF就算了吧）**

* 另外，对于这些很类似于数学题的题目，一定要发现数学规律，不要企图用【好脑袋+笨办法】，也就是【计算机+低效算法】来勉强解决问题——这不是你刷题的意义。

2021.11.22AC，2021.11.23笔记



#### [414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)

> 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。
>
> 示例 1：
>
> 输入：[3, 2, 1]
> 输出：1
> 解释：第三大的数是 1 。
> 示例 2：
>
> 输入：[1, 2]
> 输出：2
> 解释：第三大的数不存在, 所以返回最大的数 2 。
> 示例 3：
>
> 输入：[2, 2, 3, 1]
> 输出：1
> 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
> 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
>
>
> 提示：
>
> 1 <= nums.length <= 104
> -231 <= nums[i] <= 231 - 1
>
>
> 进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？
>

进阶要求O(N)时间，说明这题可以一次遍历实现，那就来吧。

* 一开始的思路：

  类似找最大值的办法，用三次遍历，循环一次找第一大；再循环一次（忽视第一大）找第二大；再循环一次（忽视第一大和第二大）找第三大。

* 后来的思路：

  上面的思路很简单，也确实是O(N)时间，不过具体的说，是O(3N)——能不能只遍历一次？可以！一次性声明一个长度为3的int数组，存放当前找到的前三大的数字就好了嘛！——等等，为什么要数组？没错，直接声明三个变量int型max1、max2、max3即可。

  * 具体遍历过程很容易理解：

    首先为三个变量赋初值Integer.MIN_VALUE，然后一次遍历，为每个元素找到前三榜单中属于它的合适位置，并更新榜单（把原来的前三大元素挪一挪位置），当然遇到重复元素就直接忽略。最后按照题目要求，**判断榜单第三位是否有元素占据**，如果有就返回它（max3），如果没有就返回榜单第一位（max1）。

  * 遍历结束后，如何“判断榜单第三位是否有元素占据”？即如何判断是否存在第三大元素？**这个小细节其实才是**

    既然一开始设置max3初始值为Integer.MIN_VALUE，那我最后直接判断max3的值还是不是Integer.MIN_VALUE，不就好了？不行，因为题目要求中num[i]的取值范围有覆盖到Integer.MIN_VALUE，准确的说，是覆盖到了int型的整个取值范围——int型。等等，那我直接把三个int型变量改为**long型**，初值赋为Long.MIN_VALUES不就好了？没错！**只有把初始值设得比num[i]的可取最小值更小，才能完美解决问题。**

2021.11.26



#### 数组第2轮 - 小结&经验&感悟

* **画图很重要**，遇到比较难理解的算法（比如有多个指针的），可以拿张草稿纸，简单画几下，比在头脑中想象会简单很多。
* 渡过纯新手纯小白阶段以后，就可以**逐渐不用暴力解**了。一道题拿到手，如果你一看就知道暴力解怎么写、能通过，也知道这样写效率低、不优雅，那就别写暴力解了，时间宝贵，不如仔细审题，发现规律，把时间花在自己写出高效解法上。
* 一道题，拿到手看了20分钟，啥思路都没有？别想了。写了30分钟，连暴力解都A不了？别写了。不要浪费太多时间，直接看题解！总结：**不恋战！**
* 接着上一条：**做题要计时**，心里有底。

2021.11.26





### 字符串第2轮 - 简单\*19+中等\*1

#### [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

> 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
>
> 字符          数值
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000
> 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
>
> I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
> X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
> C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
> 给定一个罗马数字，将其转换成整数。
>
> 示例 1:
>
> 输入: s = "III"
> 输出: 3
> 示例 2:
>
> 输入: s = "IV"
> 输出: 4
> 示例 3:
>
> 输入: s = "IX"
> 输出: 9
>
> 输入: s = "MCMXCIV"
> 输出: 1994
> 解释: M = 1000, CM = 900, XC = 90, IV = 4.
>
>
> 提示：
>
> 1 <= s.length <= 15
> s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
> 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
> 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。

这题的题目描述略长，但是看懂了怎么算（就是给一个正确的罗马数字，你能在纸上算出来，这就叫**手写会算**，只是差**代码实现**）。

怎么算？从字符串末尾往前遍历，即从右往左遍历。

* 首先解决单个罗马数字的转化问题：因为只有7个，7种情况，所以直接多写一个方法，用swtich返回对应值即可。

  评论区也有人用哈希表存对应关系的，虽然也是O(1) O(1)，但是每次运行都要手动加入键值对，又不好看，又浪费空间时间，不如直接写死在方法里。

* 正常情况下，每次都给最终值加上这个罗马数字所对应的阿拉伯数字（如V对应5）。所以要声明一个变量存最终值，或者说总和。
* 特殊情况下，会遇到当前罗马数字比它右边的罗马数字小，此时需要减去当前罗马数字的对应阿拉伯数字。所以要声明另一个变量存目前遇到的最大的罗马数字（正常情况下，从右往左是非降序的，所以“比它右边的罗马数字小”其实也就是“比目前遇到过的最大罗马数字小”）。

---

*记录一点题外话，这题我今天花了25分钟A了，一次提交成功。*

*成绩：96% 87% 4ms 38.4MB 时间O(N) 空间O(1)。*

*代码：*

```java
class Solution {
    public int romanToInt(String s) {
        int len = s.length();
        int value = 0;
        int largestNum = getInteger(s.charAt(len - 1));
        for(int i = len - 1; i >= 0; i--) {
            int currentNum = getInteger(s.charAt(i));
            if(currentNum > largestNum) {
                value += currentNum;
                largestNum = currentNum;
            }
            else if(currentNum == largestNum) {
                value += currentNum;
            }
            else {
                value -= currentNum;
            }
        }
        return value;
    }

    public int getInteger(char romanNumeral) {
        switch(romanNumeral) {
            case 'I': return 1;
            case 'V' : return 5;
            case 'X' : return 10;
            case 'L' : return 50;
            case 'C' : return 100;
            case 'D' : return 500;
            case 'M' : return 1000;
            default : return -1;
        }
    }
}
```

*而当年第一次刷力扣的我（9个月前），写了不知道多久，从一次提交就通过来看，应该是自己写不出来，看题解才做出来的。*

*成绩：31% 22% 7ms 39MB 时间O(N) 空间O(1)*

```java
class Solution {
    public int romanToInt(String s) {
        char[] roman = s.toCharArray();
        Map<Character, Integer> hashmap = new HashMap<Character, Integer>();
        hashmap.put('I', 1);
        hashmap.put('V', 5);
        hashmap.put('X', 10);
        hashmap.put('L', 50);
        hashmap.put('C', 100);
        hashmap.put('D', 500);
        hashmap.put('M', 1000);
        int sum = 0;
        for(int i=0; i<roman.length; ) {
            if(i==roman.length-1) {
                sum += hashmap.get(roman[i]);
                return sum;
            }
            int a = hashmap.get(roman[i]);
            int b = hashmap.get(roman[i+1]);
            if(a<b) {
                sum += b-a;
                i += 2;
            }
            else {
                sum += a;
                i++;
            }
        }
        return sum;
    }
}
```

*差距，进步，一目了然。*

---

#### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

> 编写一个函数来查找字符串数组中的最长公共前缀。
>
> 如果不存在公共前缀，返回空字符串 ""。
>
> 示例 1：
>
> 输入：strs = ["flower","flow","flight"]
> 输出："fl"
> 示例 2：
>
> 输入：strs = ["dog","racecar","car"]
> 输出：""
> 解释：输入不存在公共前缀。
>
>
> 提示：
>
> 1 <= strs.length <= 200
> 0 <= strs[i].length <= 200
> strs[i] 仅由小写英文字母组成

首先想到，纵向扫描每一个字符串的第n位前缀字符，如果都相等，则该字符可以“加入”公共前缀字符串，然后继续纵向扫描第n+1位前缀字符；如果有不相等的，则所有循环结束，上一轮得到的公共前缀字符串就是最终结果。

这里有两层循环，外层循环次数是纵向扫描的字符个数，即所有字符串中最短那个的长度（公共前缀字符串的长度不会超过它）；内层循环次数是字符串数组的长度。

所以要先找到最短字符串的长度，再来两个for遍历，时间O(N*N)，空间O(N)。

2021.11.27





#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
>
> 输入：s = "([)]"
> 输出：false
> 示例 5：
>
> 输入：s = "{[]}"
> 输出：true
>
>
> 提示：
>
> 1 <= s.length <= 104
> s 仅由括号 '()[]{}' 组成

括号匹配问题是栈的经典应用场景之一。这题的思路非常清晰，不需要再记什么思路笔记了。*（想起当初第一次做力扣的时候做这些题真是太难了）*

2021.11.29





#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

> 说明：
>
> 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
> 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
>
> 提示：
>
> 0 <= haystack.length, needle.length <= 5 * 104
> haystack 和 needle 仅由小写英文字符组成

借用评论区最高赞```@取个名字真难```的评论：

> 无语，这种题目就算了吧。要是说考察寻找字串快的可以用到KMP等方法，难度应该要归类到困难。要是用各种语言的内置函数，又不知道作为一道算法题的意义何在？考察对语言的熟悉程度？差评！

我用暴力解的，提交一次过，具体算法不说了，暴力解很简单的，这题对于现在的我来说确实没什么营养（但是研究KMP又没必要）。

后来我又回看9个月前的提交，优化了一个小细节（判断匹配成功不用flag，直接看targetIndex有没有走完就行），成绩大概在10% 90%，不纠结了。KMP算法实在复杂，以后再说。

*还有个事，就是我用9个月前的同一份代码去提交，出来的执行用时、内存消耗和之前完全不一样，而且相差非常大——相差几个量级，我也不知道为什么，困惑。*

2021.11.30





#### [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

> 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。
>
> 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
>
> 示例 1：
>
> 输入：s = "Hello World"
> 输出：5
> 示例 2：
>
> 输入：s = "   fly me   to   the moon  "
> 输出：4
>
>
> 提示：
>
> 1 <= s.length <= 104
> s 仅有英文字母和空格 ' ' 组成
> s 中至少存在一个单词

这题拿到手，第一个想到从后往前遍历，遇到空格就停，这样最后一个单词的长度就算出来了嘛。

但是我忽略了示例2，如果最后面是空格呢，我自己AC的低效解法是用一个boolean变量记录是否遇到过非空格字符，再用一个int变量记录（从后往前数）第一个空格字符的下标，这样也能AC，*100% 50%——看起来不错？100%是因为0ms，看一下详情就知道0ms占通过的一半，毕竟这题实现O(N) O(1)没什么难度。这时候就要挑战一下，看能否改得更简洁更省内存了。*

我在题解区看到一个非常优雅的代码（100% 90%），短到我可以直接贴上来：（我参照他的思路自己写了一个100% 80%，代码没这个优雅，因为我在while里面还写了一对简单的if-else——其实**简单的if-else一般是可以想办法精简掉的**）

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int i = s.length() - 1;
        while(i >= 0 && s.charAt(i) == ' ') i--;        //去掉末尾的空格字符，找到最后一个非空格字符的下标i
        int j = i;
        while(j >= 0 && s.charAt(j) != ' ') j--;        //从i开始,从后往前，找到第一个空格字符的下标j
        return i - j;
    }
}
```

这个思路是不一样的，这里我们**先去除字符串最后的空格**，再回到最简单的最初的算法——找到空格。

2021.12.01





#### [67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

> 给你两个二进制字符串，返回它们的和（用二进制表示）。
>
> 输入为 非空 字符串且只包含数字 1 和 0。
>
> 示例 1:
>
> 输入: a = "11", b = "1"
> 输出: "100"
> 示例 2:
>
> 输入: a = "1010", b = "1011"
> 输出: "10101"
>
>
> 提示：
>
> 每个字符串仅由字符 '0' 或 '1' 组成。
> 1 <= a.length, b.length <= 10^4
> 字符串如果不是 "0" ，就都不含前导零。

自己写了40分钟没写出来，代码太长太繁复了，遂放弃，转向题解区寻求答案。

p.s.说在前面：为什么这个解法28% 58%我都采用？因为看评论区，似乎有很多人都是流氓解法，调用现成函数，三行搞定。这种我们不管它，但它确实会影响平均成绩。而且这题我光理解正确题解也看了挺久的，所以，点到为止，不追求再复杂再高效的。下次遇到再研究。

回归正题，其实这题最关键的就是一个**二进制的进位问题**，搞懂了进位，实现的时候用暴力解法，写各种if-else，就算不优雅不简洁，也总归是可以AC的。我AC不了就是因为二进制的进位没搞懂。

整体思路如下：

1. 我们先声明一个StringBuffer对象，用来生成结果数字（一位一位append上去）。然后对代表二进制数字的两个字符串进行倒序遍历，**逐位相加、进位**。最后把这个StringBuffer翻转一下（从低位到高位的倒序遍历，加进StringBuffer里的结果是正序的低位到高位），就是我们的最终结果，然后toString()返回。

2. 在逐位相加、进位之前，我们需要声明一个`n`变量，存储较长字符串的长度。为什么不是较短的？因为我们需要遍历到每一位数，哪怕较长字符串的那一位数字，在较短字符串中没有对应数字跟它相加，也要遍历到那里，做相应处理。

   * 这里你其实也可以先手动给较短字符串的前面补上足够的“0”，直到两个字符串长度一致，就没用长短之分了。

3. 还需要声明一个`carry`变量，存储目前需要进位多少当前位数。

   * 以十进制为例可能比较容易说明一点：比如我现在要开始做百位的相加，carry为1就说明，我现在有一个额外的“百”想要加进结果里。

   * 二进制同理，如果此时正在计算2^3（十进制8）位，carry为1就说明我有一个额外的2^3想要加进这个结果里，比如它可能来自于""0111"+"0111"（补上0方便演示），也可能来自于"1000"+"0000"。

4. 其实搞懂怎么进位，这题就明了。我们倒序遍历每一位数并相加（遇到不存在的位数，就当作0来加；或者你已经手动补过0了，这里就不用判断）直到遍历完较长字符串，即遍历了n次。

5. 加之前，carry已经带着上一轮留下来的需要进位的数值了，可能是0，也可能是1。然后，你需要对两个字符串的对应数字，各自来一次`carry+=0或1`。

6. 然后，现在carry记录的，就是结果需要加上的值。`append(carry%2)`，然后再`carry/=2`，同一位数的相加就完成了。

2021.12.02做，2021.12.03记





#### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
>
> 说明：本题中，我们将空字符串定义为有效的回文串。
>
> 示例 1:
>
> 输入: "A man, a plan, a canal: Panama"
> 输出: true
> 解释："amanaplanacanalpanama" 是回文串
> 示例 2:
>
> 输入: "race a car"
> 输出: false
> 解释："raceacar" 不是回文串
>
>
> 提示：
>
> 1 <= s.length <= 2 * 105
> 字符串 s 由 ASCII 字符组成

借用某题解的评论区大佬的评论：

> 回文的常见的3种做法：双指针，栈，reverse

经典**回文串问题**，三个经典思路之中，

* 栈，我确实没想到；
* StringBuffer的reverse()，我知道，不过觉得简单调api不太好，就没选（其实要处理大小写问题还是要多写几行的）
* 所以我用双指针做

一开始只调用了一个现成方法`replaceAll("[^A-Za-z0-9]", "")`，把无关字符全都删掉。

剩下的，思路其实非常非常非常简单，就是对`charAt(left)`和`charAt(right)`做比较，但由于它们有数字、小写字母、大写字母三种情况，所以我是用ascii表转的，如果是数字，就比较两个字符是否相等；如果是字母，就比较它们之差的绝对值是否等于0或32。

但是这样成绩大概只有10% 10%，最后看了题解，改用“全api”解法，而且删去前面的replaceAll正则表达式匹配（这个似乎是最消耗时间空间的），然后在循环中全部调用Character的静态方法，包括

```
isLetterOrDigit()		//不符合就left++或right--
isDigit()				//是数字字符就直接比较；是字母字符的话，需要考虑大小写问题再比较
isLowerCase()			//小写统一转大写，大写不用变
toUpperCase()
```

成绩70% 70% 3ms 38.4MB，还可以。

2021.12.5





#### [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

> 给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。
>
> 例如：
>
> ```
> A -> 1
> B -> 2
> C -> 3
> ...
> Z -> 26
> AA -> 27
> AB -> 28 
> ...
> ```
> 示例 1：
>
> 输入：columnNumber = 1
> 输出："A"
> 示例 2：
>
> 输入：columnNumber = 28
> 输出："AB"
> 示例 3：
>
> 输入：columnNumber = 701
> 输出："ZY"
>
> 示例 4：
>
> 输入：columnNumber = 2147483647
> 输出："FXSHRXW"
>
> **提示：**
>
> - `1 <= columnNumber <= 231 - 1`

**做这类进制转换的题之前，首先要能够手算，如果手算能算出来，那么代码实现其实很简单。**

来看代码吧，最关键的就是一个特殊设定——这是一个**没有0但有26的26进制**。

- 所以如果遇到刚好是26的n倍的数，本来应该往高位加n，这里要改成给低位加1，再给高位加n-1，也就是分一个26给低一位，毕竟我们不能用到零。比如：十进制5 2，转换成二十六进制应该是20，但是这里只能变十六进制1 26。

- 如果不是上面那种刚好是26倍数的情况呢？那就和正常的进制转换没什么两样，对26求余，余多少，当前位就是多少；然后继续处理高一位。

```java
class Solution {
    public String convertToTitle(int columnNumber) {            //没有0却有26的【26进制】
        StringBuilder str = new StringBuilder();
        while(columnNumber > 0) {
            int a = columnNumber % 26;
            //余数为0，说明此时columnNumber刚好是26的n倍：因为没有不存在0，所以此时当前位要加26，高一位要加n-1
            //余数不为0，则按正常进制转换来做：余多少，即代表当前位要加多少
            str.append(a == 0 ? 'Z' : (char)('A' + a - 1));
            //columnNumber-1只会影响colomnNumber刚好是26倍数的情况（即余数为0的情况）
            columnNumber = (columnNumber - 1) / 26;
        }
        return str.reverse().toString();
    }
}
```

这种算法100% 55% 0ms 35.6MB，也不错了。

* 也可以写一个`char toChar(int num)`方法，就可以省去那些强制类型转换。

* 也可以从高位往低位处理，就是先处理除以26得到的商，再处理余数，就可以不用reverse()。

本题AC于2021.12.6，但自那天之后，整个12月我都没空再做力扣，当然也就没有写题解。

本题解补写于2022.1.3。





#### --------------------

12月是紧张的一个月（详见[大二下2  期末学习安排](C:\Me\杂\笔记\0往期规划\2大二\2.1.1  大二下2  期末学习安排.md)中的v2021.12.03），尽管最后一个星期考试压力比较小，但是又连续出去五天，也没什么时间。等到回家第三天才有时间重拾力扣。





#### [171. Excel 表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

> 难度简单302
>
> 给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。
>
> 例如，
>
> ```
>     A -> 1
>     B -> 2
>     C -> 3
>     ...
>     Z -> 26
>     AA -> 27
>     AB -> 28 
>     ...
> ```
>
> **示例 1:**
>
> ```
> 输入: columnTitle = "A"
> 输出: 1
> ```
>
> **示例 2:**
>
> ```
> 输入: columnTitle = "AB"
> 输出: 28
> ```
>
> **示例 3:**
>
> ```
> 输入: columnTitle = "ZY"
> 输出: 701
> ```
>
> **示例 4:**
>
> ```
> 输入: columnTitle = "FXSHRXW"
> 输出: 2147483647
> ```

26进制转10进制，不管是特殊的26进制还是普通的，算法都是一样的，因为每个位数代表的大小都一样。也可以用10进制的机制去依葫芦画瓢，非常容易理解。

我写了15分钟，一次性AC，这道题就不用再说什么了。

2022.01.03





#### [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

给定两个字符串 ***s*** 和 ***t***，判断它们是否是同构的。

如果 ***s*** 中的字符可以按某种映射关系替换得到 ***t*** ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

> 示例 1:
>
> 输入：s = "egg", t = "add"
> 输出：true
> 示例 2：
>
> 输入：s = "foo", t = "bar"
> 输出：false
> 示例 3：
>
> 输入：s = "paper", t = "title"
> 输出：true
>
>
> 提示：
>
> 可以假设 s 和 t 长度相同。
>
> Constraints:（英文版给的提示信息比较多）
>
> 1 <= s.length <= 5 * 104
> t.length == s.length
> s and t consist of any valid ascii character.

既然提到映射，很容易想到用哈希表做。“某种映射关系”就用哈希表的key-value来表示。

读完题目发现这就是一种**一对一映射**。（当然第一次看题目还是要理解一下的，我一开始还以为“某种映射关系”是指对应字符的ascii值之差是固定的）

我们要尽量做到一次遍历，所以要边遍历边存。直接拿代码注释来看吧：

1. 解法一  哈希表  13ms 38.2MB  56% 80%

   ```java
   class Solution {
       public boolean isIsomorphic(String s, String t) {
           HashMap<Character, Character> hashMap = new HashMap<>();
           for(int i = 0; i < s.length(); i++) {
               char a = s.charAt(i);
               char b = t.charAt(i);
               //如果a b都没被用过，就可以建立新的映射关系
               //否则，就要判断当前a b是否满足映射关系（进入else-if）
               if(! hashMap.containsKey(a) && ! hashMap.containsValue(b)) {
                   hashMap.put(a, b);
               }
               //如果key中不存在a，说明value中存在b，且b对应的key肯定不是a
               //如果key中存在a，就看a对应的value是不是b
               else if(! hashMap.containsKey(a) || hashMap.get(a) != b) {
                   return false;
               }
           }
           return true;
       }
   }
   ```

2. 解法二  数组表  2ms 38.7MB  99% 8%

   ```java
   class Solution {
       public boolean isIsomorphic(String s, String t) {
           char[] a = s.toCharArray();
           char[] b = t.toCharArray();
           //下标是a的ascii值，该下标对应元素是此a映射到的b
           char[] arrayMapA2B = new char[128];
           //下标是b的ascii值，该下标对应元素是此b是否存在
           boolean[] arrayMapB = new boolean[128];
           //for循环里的逻辑与哈希表解法完全相同！
           for(int i = 0; i < a.length; i++) {
               if(arrayMapA2B[a[i]] == '\0' && ! arrayMapB[b[i]]) {
                   arrayMapA2B[a[i]] = b[i];
                   arrayMapB[b[i]] = true;
               }
               else if(arrayMapA2B[a[i]] == '\0' || arrayMapA2B[a[i]] != b[i]) {
                   return false;
               }
           }
           return true;
       }
   }
   ```

值得一提的是这个数组表，我愿称之为ArrayMap，像前面217题用过的差值表，就属于数组表的一种，都是要结合具体题目来构建的。

数组表就是空间换时间，用于替代简单情境下的哈希表。

2022.01.04





#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

> 示例 1:
>
> 输入: s = "anagram", t = "nagaram"
> 输出: true
> 示例 2:
>
> 输入: s = "rat", t = "car"
> 输出: false
>
>
> 提示:
>
> 1 <= s.length, t.length <= 5 * 104
> s 和 t 仅包含小写字母

题目很好理解，就是要每个字母的出现次数相等，第一时间想到哈希表。

（当然也可以用数组表，'Z'与该字母之差为下标，该字母出现次数为值，只需要一个int[26]）

一开始我是先用两个哈希表记录两个字符串的字母出现次数（两次遍历），然后再依次进行比较（又两次遍历），很低效。

>  这题有两种特殊情况，一是s有t没有的字母，二是t有s没有的字母。所以比较时不能只比较一次。

解法一：后来我改用将s.t转换成char数组并**排序**，只有每个下标下的元素一一对应，才符合要求。**（长度不相等就不用说啦，一进入程序就专门排除掉了）**

* Arrays的API，新学的

  ```java
  static boolean	equals(char[] a, char[] a2)
  Returns true if the two specified arrays of chars are equal to one another.
  ```

<a name="257解法2">解法二</a>：从评论区看到其实哈希表可以这样做：用一个哈希表记录s中各字符串出现个数（一次遍历），然后在t中，遇到没出现过的字母就直接return false，遇到记录过的字母就把出现次数减一，遇到出现次数仅为1的字母，本来要减一，这里直接remove，相当于没出现过（又一次遍历）。最后判断哈希表是否为空

原理其实就是**相互抵消**。注意此时已经保证s.t的长度是相等的，那么如果是字母异位词，就应该刚好全部抵消。和解法一有异曲同工之妙——字符不能多，不能少。

* HashMap的API，复习一下

  ```java
  V	getOrDefault(Object key, V defaultValue)
  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
  V	remove(Object key)
  Removes the mapping for the specified key from this map if present.
  ```

2022.01.05





#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img" style="zoom: 50%;" />
>
> ```
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
> ```

这题可以选择深度优先遍历或者广度优先遍历，可以是递归方式，也可以是非递归方式。

我选择的是自己比较熟悉的深度递归，但是，这题我还真没做出来，因为我没能处理好**路径怎么存**的问题，后来看题解才懂的。

题目给了一个方法，`public List<String> binaryTreePaths(TreeNode root)`，很容易想到要再写一个方法，这个方法要满足三个要求：

* 能够处理传入的任意结点
* 记录当前结点对应的所谓当前路径（一步一个脚印），还必须能够回退路径，比如以上图为例，当走到5时，路径是“1->2>5”，然后走到3，此时路径能否回退到"1->3"？
* 处理当前结点接下来能走什么路径
* 还要能够记住最终结果的List，只要一找到叶子结点，就将这个当前路径加进结果List

所以我们要增加的方法要这么写：（用StringBuilder是因为出现很多字符串拼接）

`public void binaryTreePaths2(TreeNode asRoot, StringBuilder currentPath, List<String> paths)`

1. 一步一个脚印，进入方法，第一步先把当前结点的值加进当前路径中。
2. 如果当前结点是叶子结点，那么路径也到头了，就把当前路径加进结果List中，然后结束方法。
3. 如果当前结点不是叶子结点，那就将非空的左结点和右结点递归传入这个方法的下一层递归
   * 进入下一层递归时，结果List依然是那个List，永远都是传引用
   * 进入下一层递归时，当前路径不能都传引用，因为如果左右结点都用同一个StringBuilder记录路径，那样就没法回退了。所以要new一个新的StringBuilder给左结点用，然后旧的StringBuilder给右结点，这样就不会乱。

**时间复杂度分析——O(N*N)：**

每个结点仅访问一次，O(N)，但是访问结点时，可能发生字符串拷贝，比如toString(strBuff)或者new StringBuilder(str)，所以又有一次O(N)

**空间复杂度分析——O(N*N)：**

每个结点仅访问一次，O(N)，但是访问结点时，由于是递归，所以当你访问第N层的结点时，其实你需要前面1~N-1层的空间来支撑。比如以上图为例，访问5时，内存中必须先存着1和3。

2022.01.06





#### [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。

> 示例1:
>
> 输入: pattern = "abba", str = "dog cat cat dog"
> 输出: true
> 示例 2:
>
> 输入:pattern = "abba", str = "dog cat cat fish"
> 输出: false
> 示例 3:
>
> 输入: pattern = "aaaa", str = "dog cat cat dog"
> 输出: false
> 示例 4:
>
> 输入: pattern = "abba", str = "dog dog dog dog"
> 输出: false

**双向映射嘛，可以用哈希表做。**

* 首先用`String[] words = str.split(" ")`把str切割成一个个单词，然后比较单词个数与pattern字母个数是否相等，不相等就肯定false；相等再继续。

* 建立一个哈希表<pattern中的字母,  str中的单词>

* 然后遍历一次words数组（或者pattern，反正长度一样），如果哈希表中不存在该字母key，同时不存在该单词value，就put一下；如果只是不存在该字母key，或者虽然存在key但对应的value不对，就返回false
* 如果能够完成遍历，就说明每个字母和单词都一一对应，返回true

哈希表做法是我自己想到的，已经能做到双9，只要优化一下即可，如下：

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if(words.length != pattern.length()) {
            return false;
        }
        //第二波优化
        //优化前：1ms  36.1MB  90%  90%
        //Map<Character, String> hashMap = new HashMap<>();
        //优化后：1ms  36.0MB  90%  93%
        Map<Character, String> hashMap = new HashMap<>(35);		//(int)(expectedSize / 0.75F + 1.0F)
        for(int i = 0; i < words.length; i++) {
            char p = pattern.charAt(i);
            String word = words[i];
            if(! hashMap.containsKey(p) && ! hashMap.containsValue(word)) {
                hashMap.put(p, word);
            }
            //第一波优化
            //优化前：1ms  36.4MB  90%  36%
            //else if(! hashMap.containsKey(p) || ! hashMap.get(p).equals(word)) {
            //优化后：1ms  36.1MB  90%  90%
            else if(! hashMap.getOrDefault(p, "").equals(word)) {
                return false;
            }
        }
        return true;
    }
}
```

**可以用哈希表做的，就可以考虑用数组表做。**（当然我一开始确实想到了，但是觉得效率太低，其实不然，尤其是对于这种key的可能数目很少的情况）

我在评论区也看到了数组表解法，实测居然可以做到**0ms  36.0MB  100%  94%**

整体思路完完全全一样，只是**改用一个String[26]，然后把字母字符与'a'之差作为下标**，就不写了。

**其实在哈希表解法的第一波优化前，数组表解法是又省时间又省空间，后来我分析、测试后发现应该就是以下两个原因：**

1. 数组表和哈希表一样，同样是空间换时间，但是哈希表在初始化时会建一个capacity为16的table数组，但是题目中pattern的字母最多有26种，所以可能会经历扩容，非常消耗时间空间；而数组表所需空间不大，又稳定，自然比哈希表高效。所以我为哈希表的初始容量设置了一个合适的值，避免发生扩容。

   参考资料：[创建HashMap时设置初始化容量_渣渣想逆袭-CSDN博客_hashmap初始化大小](https://blog.csdn.net/kevinxxw/article/details/104423093)

2. 不过，为什么哈希表两波优化过后，与数组表的成绩还是差了那么一点点？尤其是速度，一个1ms，一个0ms。

   一个合理的解释是，哈希表在存元素和找元素时，都要进行一次哈希算法，虽然时间复杂度是O(1)，但与`(int)(ch - 'a')`这样简单的类型转换后运算相比，确实更为复杂，也更消耗时间，这就是那1%的速度差距的来源。

2022.01.07





#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

> 示例 1：
>
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]

这题确实简单，因为方法里面传进来的是一个char[]数组。

思路有两个，一个是for循环遍历，边遍历边交换，走到一半就可以停了。由于在找对应元素时要大量用到数组的length来算（第`i`个元素要与第`length - 1 - i`个元素交换），所以可以直接在进入循环之前把length存起来。

另一种思路是双指针，就不用for了，用while，也很简单。

这道题简单归简单，最大的收获反而是我在评论区看到的一段对待“库函数解题”的态度。我放到这份笔记开头的<a href="#刷题方法论">“刷题方法论”</a>里了。

#### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

> **示例 1：**
>
> 输入：s = "hello"
> 输出："holle"
>
> **示例 2：**
>
> 输入：s = "leetcode"
> 输出："leotcede"

这题要做出来很简单，但优化还是要费点心思。最终我的解法是双指针&哈希表&if-else，3ms  38.5MB  82%  60%（不知道未来看到这里的我会不会有更好的方案）

我目前能想到最高效的逻辑是这样的：

* 哈希表存元音字母大小写共10个，用来快速判断某个字母是否是为元音字母
* 双指针必须有
* 字符串转换为char数组来操作，因为后续有大量随机存取

以上是基本的，没啥好说的。但是进入`while(left < right)`循环之后的逻辑，就值得探讨一下

* 来一个小while，每轮不断left++直到找到元音字母（或超出left < right的界限）
* 再来一个小while，每轮不断right--直到找到元音字母（或超出left < right的界限）
* 然后if判断left和right指针是不是在正常范围内，如果是，那说明都处于元音字母下标，就交换，并left++，right--；如果不是，说明left和right已经越界了，不用管，反正也走不了下一次while循环，等下会自动退出的
* 完成

两个小while的设计，可以保证对于每一个字符，都有且仅有一次hashSet.contains()的判断（如果小while的判断条件写的是   ` !contains && <`，那么left和right相等的交界处会多一次，别杠），不会有多余的contains判断，所以时间复杂度为O(1 N)。

2022.01.08





#### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

> 示例 2：
>
> 输入：ransomNote = "aa", magazine = "ab"
> 输出：false
> 示例 3：
>
> 输入：ransomNote = "aa", magazine = "aab"
> 输出：true
>
> 提示：
> ransomNote 和 magazine 由小写英文字母组成

这题和<a href="257解法2">257题字母异位词 的解法二</a>有异曲同工之妙。解题思想就是**相互抵消**。

**解法一：**

你可以用哈希表记录ransomNote的字母出现个数（一次遍历），然后再抵消掉magazine的相应字母的出现个数（一次遍历），当然如果减一后等于0就remove，最后判断哈希表是否为空，为空则ransomNote里的字母都被抵消完了，返回true；否则返回false。

这种解法5ms  38.8MB  27%  53%，因为哈希表内部经历了大量的复杂计算（比如计算哈希值，维护红黑树还是什么）。既然只有

既然题中指明只出现小写英文字母，那就用数组表吧。

**解法二：**

与解法一思路完全一致，但是不用计算哈希值，也不用remove——不管出现次数等于多少，抵消的时候只管减一就行。最后判空时（多一次遍历，但O(1)），如果字母出现次数有没被抵消完——大于0的，就返回false；否则返回true。

一开始我没用这个，是因为我觉得最后要遍历一次数组表来判空太耗费时间。但事实证明，**在这道题里面，数组表的全程简单运算下来的速度还是要快过“看似高效实则复杂”的哈希表**。这种解法1ms  38.7MB  99%  59%

**解法三：**

有没有办法对解法二进行优化，省去最后那次单纯的判空？有的，那就是不要用数组表记录ransomNote的字母出现次数，而是用来记录magazine的字母出现次数，然后用ransomNote的字母来抵消。抵消过程中，如果magazine那边字母次数不够用，没得抵消，就直接返回false；否则次数减一；直到退出循环，返回true。

不过，这样的“优化”，速度没快多少，毕竟省掉的那次判空其实是很快的，length也固定在26，全都是简单计算，时间O(1)，空间O(1)；反而消耗多了一点空间，因为在抵消过程中要做判断。这种解法的成绩是1ms  38.9MB  99%  37%，其实我也不知道为啥消耗多了0.2MB。

2022.01.09





#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

难度**中等**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

> 示例 1:
>
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 示例 2:
>
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> 示例 3:
>
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> 示例 4:
>
> 输入: s = ""
> 输出: 0
>
>
> 提示：
>
> 0 <= s.length <= 5 * 104
> s 由英文字母、数字、符号和空格组成

心血来潮，做了一下中等题，用了一个半小时才AC，1ms  38.5MB  100%  50%  O(N)  O(N)，经过实现上几个小细节的优化，可以达到2ms  38.3MB  96%  89%  O(N)  O(1)。不过题解区也没有更亮眼的解法，就按照我这个来吧。

**思路**

看懂了题意后，我的大致思路是这样的：

* 维护一个`maxLength`，记录我们目前为止找到的满足“无重复字符”的最长子串的长度

* 维护两个指针`start`和`en`d，记录当前这一轮找到的满足“无重复字符”的子串的开始、结束下标；
* 用`end`遍历字符串，一点一点移动，并记录下遍历过的每一个字符的最近出现位置；
* 当我们发现当前字符上一次出现的位置，刚好处于当前子串之内，说明我们找到了重复元素，那这个子串也就到头了，这一轮的任务完成
  * 首先，这个子串的长度就是`end - start`，和`maxLength`相比后取最大值存入`maxLength`
  * 然后，关键来了，把`start`更新到“当前字符上一次出现的位置”的后一位，下一轮，一个新的子串就从这里开始
* 无论有没有发现重复元素，都要把“当前字符上一次出现的位置”更新为`end`，然后end也往前挪一位，才能继续遍历

这种思路，使得`start`和`end`都不用回退，一次遍历即可，实现了O(N)的时间复杂度；至于用到的内存空间，如果不把字符串转化为char[]数组的话（确实没有必要，因为`s`长度可能很长，单独创建出这块空间会消耗大量内存。可以用一个局部变量暂时存下`s.charA(end)`的值，使得每一次遍历最多只需要执行一次`charAt()`），那么空间复杂度甚至可以优化到O(1)。

**经验**

这题拿到手，最好先在纸上画一画，把解法步骤画明白，或者至少要能够看着示例，在心里算出正确答案——在这个前提下再解决**“怎么用代码实现我刚才在纸上/头脑里的有效思路？”**的问题。

**代码&截图**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        //排除长度为0的情况
        if(s.length() == 0) return 0;
        //当前正在查找的【无重复字符的子串】的头下标
        int start = 0;
        //当前正在查找的【无重复字符的子串】的尾下标的下一位
        int end = 1;
        //构建int型数组表，记录某个ascii字符中上一次出现的位置（全部手动设置为-1，表示未出现过）
        int[] arrayMap = new int[128];
        for(int i = 0; i < arrayMap.length; i++) {
            arrayMap[i] = -1;
        }
        //目前找到的【无重复字符的最长子串】的长度
        int maxLength = 0;
        
        int length = s.length();
        arrayMap[s.charAt(0)] = 0;
        while(end < length) {
            //当前字符在数组表中的下标
            int index = (int)(s.charAt(end));
            //该字符出现过，并且上一次的出现位置就在当前子串之中（即重复元素）
            if(arrayMap[index] != -1 && arrayMap[index] >= start) {
                //更新maxLength（改完maxLength才能改start）
                maxLength = Math.max(maxLength, end - start);
                //更新start，将它放到该重复字符的上次出现位置的后一位，以便开始新一轮的查找（改完start才能改arrayMap[index]）
                start = arrayMap[index] + 1;
            }
            //无论什么情况，都肯定要更新arrayMap的数据，并把end往右移一位，继续遍历
            arrayMap[index] = end;
            end++;
        }
        //end==length时退出循环，此时end-1为最后一个子串的尾坐标，所以必须考虑它的长度
        maxLength = Math.max(maxLength, end - start);
        return maxLength;
    }
}
```

p.s.这题我发布了题解[Java高效解法 击败双90% 不用滑动窗口 2ms 38.3MB 96% 89% O(N) O(1) - 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/java-2ms-383mb-96-89-on-o1-by-matty_lear-771a/)

2022.01.11





#### [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

> **示例：**
>
> ```
> s = "leetcode"
> 返回 0
> 
> s = "loveleetcode"
> 返回 2
> ```
>
> Constraints:
>
> 1 <= s.length <= 105
> s consists of only lowercase English letters.

太简单啦，数组表`int[] count = new int[26]`记录出现次数，遍历一次字符串，统计一下出现次数；再遍历一次字符串，找到第一个出现次数为1的就返回当前遍历到的下标，要是都没有就返回-1。这种解法4ms  38.8MB  90%  75%  O(2N)  O(1)。

当然还有其他解法，了解一下：

* 哈希表记录字母出现次数，思路完全一样
* 哈希表（或数组表）记录字母首次出现的位置。
  * 第一次同样是遍历字符串，遇到未出现过的字母，就记下首次出现位置；遇到出现过的字母，就将其首次出现位置记为-1，因为它不是我们想要的
  * 第二次是遍历哈希表（或数组表），找到存值最小的不为-1的值（存值不为-1就等于只出现过一次，存值最小就等于对应字母出现位置最靠近字符串左边），返回它；找不到就返回-1

#### [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。

字符串 ***t*** 由字符串 ***s*** 随机重排，然后在随机位置添加一个字母。

请找出在 ***t*** 中被添加的字母。

> **示例 1：**
>
> ```
> 输入：s = "abcd", t = "abcde"
> 输出："e"
> 解释：'e' 是那个被添加的字母。
> ```
>
> **示例 4：**
>
> ```
> 输入：s = "ae", t = "aea"
> 输出："a"
> ```
>
> **提示：**
>
> - `0 <= s.length <= 1000`
> - `t.length == s.length + 1`
> - `s` 和 `t` 只包含小写字母

这题做出来本来没什么，但是我一看题解区才知道，原来还有其他两种巧妙解法！！以下解法一是我自己用的，解法二和解法三是学到的！

**解法一：数组表记录出现次数	2ms  36.6MB  77%  80%  O(2N)  O(1)**

最近真是用数组表用上瘾了，都没想到其他巧妙的思路。

遍历`s`，先用数组表记录`s`中各个字母的出现次数（加一），然后遍历`t`，抵消掉各个字母的出现次数（减一），要是没得抵消了，说明这个字母是多出来的，返回它。

**解法二：ASCII值总和之差	1ms	36.7MB  98%  62%	O(2N)  O(1)**

声明一个`int asciiSum`，遍历`t`（多出一个字母的哪个字符串），把`t`每个字符的ascii值加上，再遍历`s`（原字符串），用`s`中每个字符的ascii值抵消减去，最后`asciiSum`剩下的值，就是多出来的那个字母的ascii值

**解法三：异或	1ms	36.7MB  98%  53%	O(2N)  O(1)**

回顾一下[异或运算规律_ddpluspro的博客-CSDN博客_异或运算规律](https://blog.csdn.net/ddpluspro/article/details/117170645)

声明一个`int result`，然后就在对两个字符串的遍历中不断`result ^= 当前字符`，最后`return (char) result`。极其简单且巧妙的思路。

2022.01.12





#### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

> 示例 1：
>
> 输入：s = "abc", t = "ahbgdc"
> 输出：true
> 示例 2：
>
> 输入：s = "axc", t = "ahbgdc"
> 输出：false
>
>
> 提示：
>
> 0 <= s.length <= 100
> 0 <= t.length <= 10^4
> 两个字符串都只由小写字符组成。

注意“子序列”不等同于“子串”。

* 声明两个双指针`indexOfS`、`indexOfT`，再保存两个字符串长度`lengthOfS`、`lengthOfS`（省时间）
* 然后同时遍历两个字符串，遇到字符相同的，说明按顺序匹配到了，两个指针都右移；字符不相同，就把`indexOfT`右移。
* 直到`indexOfS`或`indexOfT`越界，就退出循环。此时如果`indexOfS`达到了`lengthOfS`，说明全都匹配到了，返回true，否则返回false。

看官方题解说，这种是**贪心**思想。这题还可以用DP做，但是好像效率不高并且比较难理解，就先不看了。

这个解法1ms  36.4MB  85%  56%  O(M+N) O(1)

2022.01.13



#### 字符串第2轮 - 小结&经验&感悟

* **尽量让通过率达到100%**，尽量不要出现”解答错误“的情况。要学会**自己写测试用例**，因为实际写程序的过程中，你必须在程序正式投入使用（提交）之前尽可能预料到所有可能的情况，而不是等报错了、出现Bug了再回来改代码——这是思想上的问题。
* 217、349用过差值表，205题首次提出**数组表**概念：数组表是做字符串题目的利器，因为他可以**代替HashMap<Character, T>或者HashMap<Integer, T>**，T可以是任意类型，但前面的字符或数字，要满足“可能的取值数量”是固定值。
* 这一轮，AC速度明显快了很多，一拿到手就有接近最优解的思路。Keep going !
* 力扣的判题成绩是很不稳定的，尤其是对于测试用例比较少的题（比如392题才17个测试用例，经过我和泽伟的测试，发现同一份代码能跑出不同的执行用时和内存消耗来）。所以最重要的还是得**自己分析算法的效率**，然后不用刻意追求把成绩提到很高，没有必要，自己把握好一个度，只要你觉得目前的解法是比较高效和巧妙的，就够了。

2022.01.13





## 链表第2轮 - 简单*20

链表第2轮 - 小结&经验&感悟

* 链表题，还是画图最靠谱





#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个**升序**链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：l1 = [1,2,4], l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```
> 方法头：`public ListNode mergeTwoLists(ListNode list1, ListNode list2)`

初始状态是list1 = [1,2,4], list2 = [1,3,4]，思路如下：

* 先排除list1或list2为空的情况
* 为了方便，我们通过多一次递归`if(list1.val > list2.val) {return mergeTwoLists(list2, list1);`，保证合并链表一定是通过list1的头结点构建的
* 找到两个链表的头结点中最小的那个（即list1），把它变成新链表的头结点，不用new，直接切断它的next（设为null），就可以**在原地初始化一个“新的”合并链表newList，不需要额外空间**。当然，list1指针要右移一位。

* 再声明一个rear指针指向合并链表的最后一个结点（newList指针不能动，最后要返回）
* 剩下的就简单了，时间复杂度O(M+N)的遍历，看看list1和list2现存的头结点谁最小，合并链表的rear指针就接上谁，并切断它的next（设为null），然后更新list1或list2的头指针，因为上一个头结点已经被拿去合并了；然后更新rear尾指针。
* 遍历到list1和list2两个链表的其中一个到底就退出，退出时，可能有另一个还没遍历完，由于都是升序链表，所以还没遍历完的那段链表的头结点比合并链表的尾结点还要大，全部接上rear
* 返回newList指针

<img src="C:\Me\杂\笔记\【学习笔记】\LeetCode\力扣刷题笔记.assets\LC21_1.jpg" alt="LC21_1" style="zoom: 67%;" /> <img src="C:\Me\杂\笔记\【学习笔记】\LeetCode\力扣刷题笔记.assets\LC21_2.jpg" alt="LC21_2" style="zoom: 67%;" />