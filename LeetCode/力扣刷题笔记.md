# 力扣刷题记录

## 刷题方法论

参考：

[大一计算机学生如何高效刷力扣？ - 知乎](https://www.zhihu.com/question/392882083)

怎么刷？

> @82DF-5C82：
>
> 如果学过算法和数据结构，那每天刷就行了。
>
> 第一遍以结果正确为目标，不追求运行效率，长时间没思路就看参考代码，遇到没学过的算法和数据结构就补一下。
>
> 第二遍以运行效率为目标，追求尽可能低的算法复杂度，同时加强记忆。
>
> 还有余力的话再刷第三第四遍，以熟练为目标，规定自己每题在有限的时间内AC。
>
> 最开始肯定会很吃力，慢慢地就好了。另外也要慢慢接触除了算法以外的知识体系以及工程实践，然后逐渐找到自己的方向，不要沉迷经典算法。

刷什么？

>  @代码随想录：
>
>  * 第一轮
>
>  题目类别推荐按照这个顺序来说： **数组 ->字符串 ->链表->二分查找->排序->哈希表-> 栈->队列 ->树 、递归、回溯 -> 堆** ，每一个类别只做简单的题目！而且是从通过率又高向低来刷。
>
>  这样刷过一遍之后 我们基础的数据结构和算法就已经差不多了
>
>  * 第二轮
>
>  开始做第一轮类别里面中等难度的题目
>
>  * 第三轮
>
>  这一轮的题目所代表的算法是比较难的，如果之前没有了解过，直接就刷题会很难，所以，建议把相关算法的理论看一遍，再去刷题， **先了解一下 什么是 拓扑排序、 分治，搜索树，贪心，动态规划，以及深搜和广搜**，然后再去刷题
>
>  推荐按照这个顺序去做：**拓扑排序->分治算法-> 二叉搜索树->贪心算法->动态规划-> 深度优先搜索 -> 广度优先搜索-->图->数学**
>
>  这里依然还是只做简单难度的题目 按照通过率又高向低
>
>  * 第四轮
>
>  开始尝试做第一轮里面的 困难难度的题目 （不强求，仅仅是尝试，面试中也不会太难）
>
>  同时开始做第二轮里面 中等难度的题目 （不用全都做，选一下自己一看就有想法的题目）
>
>  * 第五轮
>
>  然后开始做做leetcode分类里面 第一轮和第二轮都没有涉及到的类别的题目，相对于其他类型，面试中最常考察的是： **字典树-> 并查集 -> 树状数组->线段树 ， 这里只做简单难度的就可以了！**
>
>  剩余类型题目也凭个人喜好，选一些简单难度的题目做一做就可以了。

## 刷题心态&意义

搬运：

[为什么大家都贬低 LeetCode 的难度？ - 穷码农的回答 - 知乎](https://www.zhihu.com/question/348344092/answer/1613083757)

> 有时候感觉，人和人之间的差异，真的是太大了。就在这同一个LeetCode话题下，这里说大家都贬低LC难度，但我也看到不少人在怀疑智商，我明显属于后者。只能膜拜前者，因为我也好羡慕那些拿offer拿到手软，从而通过compete拿到大包走上人生巅峰的大牛们。
>
> 那些贬低LC的人，肯定是编程底子好，打竞赛也能拿各种牌的吧。他们来刷LC，那自然不在话下，要不然，估计也拿不到金牌吧。牛人终归是牛人，他们打通了竞赛通道，说LC简单也是理所应当的。
>
> 但大部分人，包括我，刷LC几百题才觉得勉强有点入门，看到题目才不会那么犯怵。其实大部分时候，哪怕刷了几百题，遇到新题还是一样没思路。去打LC的周赛，估计还是只能做出来前两题，四题都解出来也是很不容易的。你看看前十的那些大牛们，一个题目只需要几分钟，他们说LC简单，那就是无法可说的，人家那都是约等于秒了这些题目。不服不行。
>
> 可是大家也别忘了LeetCode的初衷！LC是为了大家为面试做准备的，而不是一个纯粹的算法竞赛网站。
>
> 在我看来，LeetCode确实不容易，但更难的其实不仅仅是写出来代码那么简单，更难的地方在于**如何在拿到一个题目的时候，三五分钟就需要理解题目并有比较清晰的解题思路，这还是要在和面试官不断沟通的情况下。**
>
> 之后就需要和面试官边交流边写完整个的代码。过程中确保代码是正确的，而且需要跑测试代码说服面试官。这个过程我觉得很难，平时练习中，这也是大家最容易忽略的。尤其是口语交流还不是很理想的同学，这个地方需要刻意练习才行。你要是不能清晰表达自己的思路，面试官都不会让你动笔写代码。
>
> **如何将自己思路清晰地和面试官交流出来，并把代码写对，这才是我们最应该在平时练习中注意到的地方！**
>
> **能做到这一点的小伙伴，估计拿到offer的概率是不低的。而这，应该是大部分人练习LC的目的，至于别人贬低不贬低，又有什么影响呢？**
>
> **反正如果你在美国的话，大公司面试基本的题目就类似于leetcode的难度，很多公司甚至题目就来自于LeetCode。**
>
> 因此，真正想要找工作上岸的同学，你甚至都不需要去在意别人怎么说，你需要的是给自己一个好的刷题计划，按部就班刷4到5百题，不断总结提高。最好是在这个过程中，边刷题边投简历，以面试代练。这样一样，你就知道自己到底是题目做不出来，还是交流不畅。然后找到自己的弱点，不断进步，最终找到工作。
>
> **等找到了工作，拿到不错的包裹，你还会去和人争论LeetCode的难度几何么？**
>
> **不用刷完LeetCode, 也比较难刷完，毕竟没那么多时间和精力，而且需要高效有目标地刷：**
>
> [LeetCode按照怎样的顺序来刷题比较好？](https://www.zhihu.com/question/36738189/answer/908664455)
>
> **Go get the job offer，fxxxk the others.**
>
> 发布于 2020-12-06 10:19

## 第2轮

### 数组第2轮 - 20道简单题

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

这题简单，直接看官方题解即可。（我的两次AC的思路和官方题解差不多）

一个是暴力枚举，O(N*N)，O(1)，能AC但成绩很差；

一个是哈希表，这也是典型的**把数组遍历的两层遍历O(N*N)改为一层遍历O(N)的思路，就是存入哈希表**，这样查找的时间效率为O(1)，当然，会牺牲一定的空间。

还有值得注意的是，**“存入哈希表”最高效的方法是【边找边存】O(N)，而不是【存完再找】O(2N)**——后者是我第二次AC的思路，就是先遍历一遍存入全部元素，然后遍历一遍来找，同样能AC但成绩很差；前者是官方题解的，确实妙。
2021.11.01AC



#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使每个元素**只出现一次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在**原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
>
>  示例 2：
>
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
>
> 提示：
>
> - `nums` 已按升序排列

注意三个条件：原地修改，空间O(1)，升序数组
我的AC思路其实就是官方题解中的双指针，preIndex相当于slow指针，i相当于fast指针，但我还记录了一个preNum，通过对比当前元素是否与上一个被加入的元素相同，来判断当前元素是否为新元素。但这是没有必要的（消耗空间），其实只需要比较一个元素是否和它的上一个元素不同就可以了。
至于官方题解的【快慢双指针】，再配合【判断是否与前一个元素相同来判断是否为重复元素】，真是太优雅了。

2021.11.02AC



#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 `nums` 和一个值 `val`，你需要**原地**移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2：
>
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

26题的增强版，不过26是要删除重复项，27是要删除特定项，此时只有两个条件：原地修改，空间O(1)。

不过照样可以用【快慢双指针】搞定，思路与26很相似。

2021.11.02AC



#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给定一个已按照 **非递减顺序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。
>
> 函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

既然是有序数组，那就要利用好“有序”这个性质，查找有序数组？那就是二分查找了。
但是一开始写二分查找我没写对（边界出了问题），后来用了LeetBook二分查找的模板1（后来发现官方题解1也是这个）才AC，但是只有36% 29%。*如果把这种成绩视为可以的话，那对这道题是一种浪费。*
看了官方题解2，没想到还有【左右双指针】这种时间效率O(N)的解法：把左指针放到最前，把右指针放到最后，计算两个指针对应元素之和，与target做比较，太大了要变小就让右指针往左挪，毕竟左指针已经最小了；太小了要变大就让左指针往右挪，毕竟右指针已经最大了。

那有没有可能错过？如果正确的下标是2和5，那么left有没有可能走到比2大的地方？right有没有可能走到比5小的地方？答案是：不可能。其实比较难理解的就在于“临界点”处。

假设left先走到了2，这时候right还太大，和也太大（left必须停下，不可能再右移），必须左移right，直至right走到5。同理，假设right先走到了5，这时候left还太小，和也太小（right必须停下，不可能再左移），必须右移left，直至left走到2。
2021.11.06AC

以上笔记为2021.11.07首次整理到markdown上

---



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
>  **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```

排序数组找目标值，时间复杂度O(log n)...就差直接把“二分查找”四个大字写出来了。

没关系，直接写即可。不得不说LeetBook给的二分模板真好用。

这个题目比普通二分就多了个条件：哪怕找不到，也要返回合适的插入位置。**结合代码和画图**可知，如果找不到，那么最后一轮一定是left/right/mid挤在同一位置，然后target > nums[mid]，然后left = mid + 1，接着left > right所以跳出循环。此时left所处位置就是插入位置。

这题很简单（也是因为我以前在力扣的另一进度做过），但是却有点感悟，那就是：**理解算法一定要多画图！**

2021.11.07



#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>
> **示例 1：**
>
> ```
> 输入：digits = [1,2,3]
> 输出：[1,2,4]
> 解释：输入数组表示数字 123。
> ```
>
> **提示：**
>
> - `1 <= digits.length <= 100`
> - `0 <= digits[i] <= 9`

直接在数组上求解即可，我的100% 80%AC思路是，从数组末尾开始遍历，

1. 如果当前数字是0~8，则直接+1返回原数组

2. 如果当前数字是9，则设为0，然后继续对下一位（i--）数字进行同样的判断，即进位——下一位数字要么+1，要么继续进位。（也可以写成递归）
3. 特殊情况，要是没有下一位，但仍需进位，也就是{9, 9, 9}的情况，就要作特殊处理一下，返回一个新数组。

看起来我的解法比较符合人类思维，其实就是模拟演算过程。

官方解法也很巧妙，它同样从数组末尾开始遍历，不过它是先找到第一个不为9的数字，让这个数字+1，然后这个数字右边的数字全部设置为0；如果所有数字都为9，那也很简单，特殊处理一下就好。

2021.11.08



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。
>
> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
>
> **注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> ```

一次过。

想要时间O(N)就用双指针。

想要空间O(1)就别用额外的数组，在原数组空间上改。

既然nums1后n位都是0，那就从后往前（从大往小）地遍历，用额外的指针记录待插入位置**nums1[j]**，用双指针找到nums1的待插入元素**nums1[i1]**和nums2的待插入元素**nums2[i2]**，再选择比较大的那个插入。

为什么while循环的循环条件是i2 >= 0？首先，既然是在num1的基础上合并nums1和nums2，nums2的元素全要搬到nums1，也就是说如果还没遍历完整个nums2，那肯定还没有完成合并；而遍历完整个nums2，也就标志着合并过程的结束。

为什么while循环条件不需要&& i1 >= 0？其实是需要的，不然i1--要是减成-1了，nums1[-1]就根本没法比较，所以在while循环体里的if-else条件中，先加一个i1 >= 0，万一i1真的不满足这个条件，就说明nums1原来的所有元素都已经搞定了，但显然nums2的还没有，所以就走else，插入nums2的元素。

为什么while循环条件不需要&& j >= 0？emmm，这个你自己算一下就知道。if-else任选一个都会移动双指针中的其中一个指针，i1从(m-1)到0最多m次，i2从(n-1)到0最多n次，哪怕i2没有提前走完（i2走完，循环体就结束），而是等i1先走完，那整个循环体最多也就走m+n次，而j从(m+n-1)到0最多也就m+n次，刚好。

2021.11.09



#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![1626927345-DZmfxB-PascalTriangleAnimated2.gif (260×240)](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>

题目上的gif图已经把本题的解法展示得清清楚楚了......这个提示太过了吧。

杨辉三角1太简单，顺便做一下杨辉三角2——

#### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

> 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: rowIndex = 3
> 输出: [1,3,3,1]
> ```

跑完杨辉三角1的代码，再返回对应row的List对象，就能AC，但是最优雅的解法肯定不是这样。没办法，看题解吧。

要获取第i行的元素，肯定需要第i-1行的；要获取i-1行的，肯定要获取i-2行的，那**O(N)**的时间复杂度是逃不过了，事实也确实如此（不考虑直接用杨辉三角的数学公式，仅仅用题目描述给的设定的话）。但空间复杂度呢？要一行一行地算，就必须一行一行地存吗？还真不少，我们可以在**“原地”修改List对象**！这样可以把空间复杂度从O(N)降到**O(1)**。

解法如下：

先手动存好第0行，然后从第1行开始遍历到第rowIndex行。

* 官方题解的方案：新行其实就是在上一行的List对象中先add一个0在末尾，元素个数就多了一个。然后从新行的第rowIndex个元素开始遍历到第1个元素（第0个元素一直为1，不用改动）。新行加的这个0的巧妙之处就在于我们这样遍历的时候，不用专门为新行的最后一个元素，即1，专门写一个add，而是可以和其他位置的元素一样，通过【上一行的第i个元素与第i-1个元素之和】来求值。

  我觉得这种写法实在没有必要，不如采用第二种。

* 另一种方案：新行先尾插入一个1（而不是0），然后从第rowIndex-1个元素开始遍历到第1个元素，或者正着遍历，都可以。这种写法比较符合正常逻辑。

2021.11.10



#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> **说明：**
>
> 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
>
> **示例 2:**
>
> ```
> 输入: [4,1,2,1,2]
> 输出: 4
> ```

我一开始的思路如下：

当你第一次遍历某元素时，你怎么知道这不是它出现的最后一次？答案是：没法知道。所以对于第一次出现的元素的处理一定是相同的，不用区别对待。要区别对待的是第二次遇到的元素，而这也是暴力解法AC的关键。

暴力解法，就是遍历，然后用HashSet存遇到的元素，hashset里没有就加入，有就删掉，最后剩下的就是那个只出现一次的数字。时间O(N)，空间O(N)，15% 9%，糟糕。

通过官方题解我还了解到其他**同水平**的解法，

* 用HashMap存每个元素的出现次数，最后用迭代器遍历哈希表找到出现次数为1的
* 用HashSet存所有元素，由于不可重复，所以HashSet里所有元素的总和的两倍减去原数组总和，就是要找的唯一数

但是！重点来了！有没有空间O(1)的解法？！有的，并且直接吊打以上解法，那就是：异或。

1. **Java中的异或运算符：`^`**

2. **运算法则：如果a、b两个数据对应的二进制位相同，则c的该位是0，否则是1。（异1或0）**

3. **推论：**
   1. **a^a=0（任何数和其自身做异或运算，结果是 00）**
   2. **a^0=a（任何数和 00 做异或运算，结果仍然是原来的数）**
   3. **如果a^b=c，那么a=b^c（异或运算满足交换律和结合律）**

这道题简直是为异或运算量身定做的！

直接遍历整个数组，从头异或到位，重复出现两次的，会变成0，0不影响别人；只出现1次的，遇到别的0也不会被影响。最终结果就是那个要求的数。

O(N) O(1)妙啊

2021.11.12



#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

> 给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
> **示例 2：**
>
> ```
> 输入：[2,2,1,1,1,2,2]
> 输出：2
> ```
>
> **进阶：**
>
> - 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

没有好的思路，那只好先暴力解AC掉（哈希表存元素出现个数），O(N) O(N)。成绩当然是很差，然后再看题解。

看了题解，发现这题解法很多。最关键的点在于，你要能够把“在数组中出现次数大于n/2”转换为**“元素个数超过其他元素个数之和”**。基于这点，就会有很多解法：

* 将数组排序，然后选数组中间的数，就是我们要找的多数元素。

  * 反证法：如果存在多数元素，但数组中间的数不是该多数元素，那么哪怕数组左边的所有元素都是同一元素，它也不是多数元素；数组右边的所有元素同理，因此当数组中间的数不是多数元素时，该数组不存在多数元素，这与前提相违背。
  * 形象法：管中有一条体长超过管长一半的蛇，往管的中间砍，必定会砍到蛇。

* 摩尔投票法：

  * 第一次看的厮杀向解释：

    > 假设不同数字相互抵消，那么最后剩下的数字，就是我们要找的多数元素。
    >
    > 我们可以把这个过程打个比方，比如现在多军对峙，假设阵营A士兵人数比其他方的人数都多，阵营A士兵能以一杀一，那么只要阵营A士兵不杀自己人（相同数字），去杀不同阵营的人（不同数字），那么最后剩下的那些士兵，就是阵营A的士兵。

  * 符合取名原意的投票向解释：

    在一次投票竞选中，已知存在一个支持者超过选民数量一半的热门候选人（但事先不知道是哪一位候选人），那么我们如果计算出投票结果，让票数最多的候选人当选？

    计算方法是将给热门候选人的投票和给其他候选人的投票“切磋”。

    1. 首先假设下一张选票的投票对象就是热门候选人，并记录下该候选人票数为1。
    2. 接下来遇到的选票如果是该候选人，那他的票数就加1；如果是其他候选人，那就互相抵消，他的票数就减1；如果减为0，就重复步骤1.
    3. 最后剩下的选票，一定是热门候选人的选票

2021.11.13



#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

> 给定一个整数数组，判断是否存在重复元素。
>
> 如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。 
>
> **示例 1:**
>
> ```
> 输入: [1,2,3,1]
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,2,3,4]
> 输出: false
> ```

这题我的思路是用HashSet存元素，存不进去的就是重复元素，提交成绩是5% 39%。

但是看了下题解，似乎也没有比这个思路更高明的题解，要么是排序后相邻比较，要么是直接用Set的轮子。**罢了，不纠结。**

*一件趣事：我原本把这个思路记为暴力解法，因为我看到题目马上就想到这种解了（下意识地觉得自己一下子想到的解法肯定是最低效的暴力解），结果看过评论之后想想，好像有人会想要用两个for循环来解诶（也许是刚开始刷力扣的我），那样就说明我有了一点小进步吧。*

---

2021.11.15补充【217. 存在重复元素】

后来去翻了下冷门的题解，终于发现一个能99% 15%的思路。

其实很好理解，和哈希表的思想是一样的，记录每个数字的出现个数。但是它用到的数据结构很有意思：

我们声明一个`int[] count`，数组长度`length`为原数组中最大值与最小值之差加一（当然要先遍历一次找到最大最小值），表示原数组若不考虑重复元素，最多只有`length`个数字。

然后，哈希表是用哈希算法来将特定元素映射到特定的存储位置，而我们用的映射算法很简单，遍历原数组，将特定数字减去最小值，得到的结果就是该数字在`count`中的下标。`count`是记录数字的出现次数的，既然能以O(1)时间查到特定数字的出现次数，那剩下的就水到渠成了吧。

同样是O(N) O(N)，这种解法的速度还是挺快的，而哈希表作为一个成熟的集合框架需要考虑很多其他的东西（但不是解这道题所需要的），可能就因为这个，速度没这种解法快；当然，由于`count`数组的长度是根据“原数组从最大值到最小值之间的每一个整数都出现“这个前提来设计的，所以很可能有空间的浪费，导致内存消耗比较大。

---

2021.11.21补充【217. 存在重复元素】

我把上面这种数据结构叫做“差值表”

#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

> 给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的 **绝对值** 至多为 *k*。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,1], k = 3
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1,0,1,1], k = 1
> 输出: true
> ```
>
> **示例 3:**
>
> ```
> 输入: nums = [1,2,3,1,2,3], k = 2
> 输出: false
> ```

1. 暴力解，遍历每个元素，然后在以该元素为中心，以k为半径的去心邻域里找到重复相同数字。（对于最开始的k个数字和最后面的k个数字，可能需要特殊处理，因为他的邻域只有一边）。时间O(N*N)，空间O(1)

2. 哈希表，记录【最近】出现位置，找到重复数字后判断下标差是否小于等于k。为什么不是记录【首次】出现位置？看示例2就懂了。

   时间O(N)，空间O(N)

3. 维护一个额外的数组index，记录元素原来的位置。然后对nums进行排序，index也跟着变化。最后再从有序数组中找到相同元素并比较他们原来的坐标。复杂度我都不想算了，麻烦！而且这不就是第二种思路吗！

我提交了第二种，结果居然90% 94%，一看官方题解，说第一种思路会超时。**罢了，不纠结。**

*因为在等某人回学校的时候，坐在行政楼前的石凳子上用手机看了两道题，所以这天就多做了两道。*

#### [228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

> 给定一个无重复元素的有序整数数组 `nums` 。
> 返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。
>
> 列表中的每个区间范围 `[a,b]` 应该按如下格式输出：
>
> - `"a->b"` ，如果 `a != b`
> - `"a"` ，如果 `a == b`
>
> 示例 2：
>
> 输入：nums = [0,2,3,4,6,8,9]
> 输出：["0","2->4","6","8->9"]
> 解释：区间范围是：
> [0,0] --> "0"
> [2,4] --> "2->4"
> [6,6] --> "6"
> [8,9] --> "8->9"
>
> 提示：
>
> 0 <= nums.length <= 20
> -231 <= nums[i] <= 231 - 1
> nums 中的所有值都 互不相同
> nums 按升序排列

其实看懂了题意，这道题的思路也就出来了：遍历，遇到相邻元素之差超过1的地方，就是旧区间的结束和新区间的开始。

但其实真正写的时候，还挺麻烦的，因为有几个重要的小细节：

1. 既然是比较相邻元素，那遍历到最后一个元素的时候该怎么办？肯定是不能从0到length-1的，这里我用的是当前元素与前一个元素比较，所以就从1到length-1，**避免数组越界**问题。用这种方式还有一个好处就是，当旧区间结束于前一个元素时，当前元素正好位于新区间的第一位。

2. 最后一位元素还有一个问题，哪怕是当前元素与前一位元素比较，要找到区间在哪结束，下标还是得继续加。但是最后一位元素的下标已经没得加了，所以还要针对这个问题，单独写一个if判断是不是到末尾了，如果是就把区间的右边界定在当前元素（即末尾元素），然后跳出循环。由于默认情况下一个区间的开始和结束下标是相同的，所以如果没有做这个**到达末尾**的判断，那么输出的最后一个区间（错误）一定只包含最后一个区间（正确的）的第一个元素。

3. 还有一个离奇的小细节，就是题目提醒里的`-2^31 <= nums[i] <= 2^31 - 1`。

   最大的int减最小的int会得到什么？（其实别说减最小的int，但凡是减一个负数，它们的差都会变成负数）

   看这个测试用例**[-2147483648,2147483647]**，num[0]-num[1] == -1！所以如果按“相邻元素之差超过1”写if，是无法处理这种特殊情况的，应该改成“**相邻元素之差不等于1**”

4. 以上两点，都是实际敲代码过程中可以发现和解决的，但是，当我AC之后发现成绩只有44% 48%，看了评论区一个100%的，发觉人家跟我思路类似？？**最关键的地方来了，频繁拼接字符串的地方，用StringBuilder或StringBuffer，不要用String直接拼接！**

   我用第一次AC的代码，把String改为StringBuilder，直接100% 95%！

2021.11.14AC



#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
>
> 示例 1：
>
> 输入：nums = [3,0,1]
> 输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
>
> 提示：
>
> n == nums.length
> 1 <= n <= 104
> 0 <= nums[i] <= n
> nums 中的所有数字都 独一无二
>
>
> 进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
>

数组的题，好像已经刷出一点感觉了。

几个麻烦的思路就一笔带过吧：要么先排序，要么哈希表。但都不够高效。咋办？

根据题目特点，数组里的数字都独一无二，题目“丢失的数字”——找丢失的数字......那就把数组所有数字加起来，再算一下本来这个范围所有数字加起来的总和，减去前者就得到丢失的数字了！

第一次AC时间100%但内存10%，原来是用了**foreach遍历数组——以后简单的数组遍历不要用这个，比较消耗内存**。改掉foreach。就100% 50%了！

从看题到写完题解，用时半小时——这才对嘛！

2021.11.17

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **示例:**
>
> ```
> 输入: [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **说明**:
>
> 1. 必须在原数组上操作，不能拷贝额外的数组。
> 2. 尽量减少操作次数。

折腾了一小时，修修改改才A...我还真的是在原数组操作的，也实现了O(N)的时间复杂度，但是6% 16...那个算法里面写太多判断了。具体可以去看原来的提交记录，我把程序注释写得很详细。但是这里不说这个算法，为啥？因为它复杂又低效。

简洁高效的解法：

把所有非0元素往前推（无需交换），然后把剩下的位置用0补上。

其实就相当于把原数组当成新数组来用，但是这种操作并不影响非0元素的相对顺序。妙啊！

*自己AC一小时，评论区大悟1分钟*

2021.11.18



#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

> 给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。
>
> 实现 NumArray 类：
>
> NumArray(int[] nums) 使用数组 nums 初始化对象
> int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）
>
>
> 示例：
>
> 输入：
> ["NumArray", "sumRange", "sumRange", "sumRange"]
> [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
> 输出：
> [null, 1, -1, -3]解释：
> NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
> numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
> numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
> numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
>
> 提示：
>
> 0 <= nums.length <= 104
> -105 <= nums[i] <= 105
> 0 <= i <= j < nums.length
> 最多调用 10^4 次 sumRange 方法

这题要通过实在太简单，一个学会Java的语法就能写出来。就直接暴力解嘛，10% 80%，空间复杂度还不错，但是每次查询都要O(N)时间——请注意“提示”的最后一行：**最多调用 10^4 次 sumRange 方法**，多次调用同一方法，如何优化？（需要具体题具体分析，如果题目没有“大量调用同一方法”这个条件，那么暴力解即最优解，没什么好优化的。）

了解一下**前缀和**。这种解法可能我见过之后就不会忘了（哭笑脸）

就是用O(N)时间初始化一个前缀和数组，长度比原数组多一位。

前缀和数组的第[i+1]项对应原数组的【第[i]项】与【第[i]项之前所有元素】之和。或许你可以理解为**原数组的前i项和**

这样在查找的时候，只需要O(1)时间，查找前缀和，一行return代码解决。妙啊！

2021.11.19



#### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> 示例 2：
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
>
>
> 说明：
>
> 输出结果中的每个元素一定是唯一的。
> 我们可以不考虑输出结果的顺序。

首先，数组是无序的，并且都要去重。一开始我想自己写【差值表】（第一次见是在【217.题 存在重复元素】），后来发现，不仅第一个数组有重复的，第二个数组也有，就卡了，然后改用【两个HashSet】，直接AC，90% 50%。后来我又对差值表做了两种小改动，也A了，100 20%左右。空间消耗确实很大，但是是真的快！和哈希算法计算哈希值相比，这个计算存储下标只需要一次减法运算...真是快到极致。

简单说一下两种思路吧，都挺好理解的。

1. 两个HashSet

   hashSet1存num1的元素。当然，会自动去重。

   然后看num2中的元素是否存在hashSet1中，如果存在，就加入hashSet2。当然，也会自动去重。

   最后用迭代器把hashSet2转换为数组返回即可。

2. 关于差值表的思想，在【217.题 存在重复元素】中已经详细记录了，这里不赘述。

   先构造一个boolean型差值表，然后遍历num1，记录num1中每个元素是否存在。当然，差值表和HashSet、HashMap那一派类似，也会去重。

   然后遍历num2，若差值表中该元素存在，则添加进结果数组中，并把差值表中该元素设为false，以避免num2中再次出现该元素——又一层去重。（这里的去重有另一种方法，就是改用int型差值表，记录出现次数。原理相似，不赘述）

   “添加进结果数组”？再声明一个数组吗？不行，长度不确定。再声明一个集合吗？不行，太消耗时间空间。就用原来的num1吧，把结果从头开始添加进num1，并记录结果数组的应有的长度，最后再根据这个长度new一个结果数组，然后复制过去就好。

p.s.你问我为什么不找找双百解法？我还真找不到，题解那里一大堆用时上了90%就拿出来发，也没考虑内存消耗成绩才50%。

2021.11.21



#### [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1：
>
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2,2]
> 示例 2:
>
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[4,9]
>
>
> 说明：
>
> 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
> 我们可以不考虑输出结果的顺序。

一开始我想用两个HashMap暴力解（实在没什么好的思路），写了将近30分钟，还没通过（解答错误）——我知道再继续修修改改，最后肯定可以，但成绩也肯定很差。既然这不是比赛，而是练习，那就没必要花太多时间去继续“完善”这个低效的解法，所以我不再继续写，直接看题解——这是更高效的做法。

1. 其实官方题解的思路完全不复杂，和我自己的写法相比，就是多了一个点醒的思路。

   这道题的解法，用纯文字来说就是，记录较短那个数组中每一个数字的“出现次数”，然后再遍历另一个数组，如果数字相同，则抵消掉该数字的一次”出现次数“，并加入结果集；当然如果“出现次数”已经为0，就无法抵消。这种解法嘛，思想容易理解，成绩中等偏上，用时和内存消耗都在70%以上。

   具体的实现，你肯定会，但是，如果不提下面几点，也许你就不会用他去优化你的代码：

   * 查找hashmap中是否存在重复元素时，你还在用`if(hashmao.contains(xxx)) {hashmap.get(xxx);}`吗？

     直接用`getOrDefault();`就好，简洁。

   * 你还在手动复制特定长度的结果数组吗？

     直接用Arrays.copyOfRange(数组, start, end)

2. 评论区有一种解法能达到99% 10%

   先用Arrays.sort(xxx)给两个数组排序（说实话我不喜欢在做力扣题的时候用这种自动排序），然后声明三个指针，两个用来遍历两个数组，还有一个用来指向结果数组的下一个存储位置。为了省空间，结果数组用num1代替，最后Arrays.copyOfRange(num1, 0, 指针3)就好。

   具体遍历的时候是这样，两个升序数组都从头开始，nums1[i]和nums2[j]比较，如果前者小，则前者指针+1；如果后者小，则后者指针+1；如果两者相等，则两者指针都+1，并加入结果数组。直到遍历完任意一个数组就退出循环。

简单题都做到这份上了，这么说吧，我建议：

* **简单题，无论什么原因，20分钟内还没通过，就看题解！**
* **除非你对自己的算法有自信，认为它值得你花时间去完善（BF就算了吧）**

* 另外，对于这些很类似于数学题的题目，一定要发现数学规律，不要企图用【好脑袋+笨办法】，也就是【计算机+低效算法】来勉强解决问题——这不是你刷题的意义。

2021.11.22AC，2021.11.23笔记



#### [414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)

> 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。
>
> 示例 1：
>
> 输入：[3, 2, 1]
> 输出：1
> 解释：第三大的数是 1 。
> 示例 2：
>
> 输入：[1, 2]
> 输出：2
> 解释：第三大的数不存在, 所以返回最大的数 2 。
> 示例 3：
>
> 输入：[2, 2, 3, 1]
> 输出：1
> 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
> 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
>
>
> 提示：
>
> 1 <= nums.length <= 104
> -231 <= nums[i] <= 231 - 1
>
>
> 进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？
>

进阶要求O(N)时间，说明这题可以一次遍历实现，那就来吧。

* 一开始的思路：

  类似找最大值的办法，用三次遍历，循环一次找第一大；再循环一次（忽视第一大）找第二大；再循环一次（忽视第一大和第二大）找第三大。

* 后来的思路：

  上面的思路很简单，也确实是O(N)时间，不过具体的说，是O(3N)——能不能只遍历一次？可以！一次性声明一个长度为3的int数组，存放当前找到的前三大的数字就好了嘛！——等等，为什么要数组？没错，直接声明三个变量int型max1、max2、max3即可。

  * 具体遍历过程很容易理解：

    首先为三个变量赋初值Integer.MIN_VALUE，然后一次遍历，为每个元素找到前三榜单中属于它的合适位置，并更新榜单（把原来的前三大元素挪一挪位置），当然遇到重复元素就直接忽略。最后按照题目要求，**判断榜单第三位是否有元素占据**，如果有就返回它（max3），如果没有就返回榜单第一位（max1）。

  * 遍历结束后，如何“判断榜单第三位是否有元素占据”？即如何判断是否存在第三大元素？**这个小细节其实才是**

    既然一开始设置max3初始值为Integer.MIN_VALUE，那我最后直接判断max3的值还是不是Integer.MIN_VALUE，不就好了？不行，因为题目要求中num[i]的取值范围有覆盖到Integer.MIN_VALUE，准确的说，是覆盖到了int型的整个取值范围——int型。等等，那我直接把三个int型变量改为**long型**，初值赋为Long.MIN_VALUES不就好了？没错！**只有把初始值设得比num[i]的可取最小值更小，才能完美解决问题。**

2021.11.26

#### 数组第2轮 - 小结&经验&感悟

* **画图很重要**，遇到比较难理解的算法（比如有多个指针的），可以拿张草稿纸，简单画几下，比在头脑中想象会简单很多。
* 渡过纯新手纯小白阶段以后，就可以**逐渐不用暴力解**了。一道题拿到手，如果你一看就知道暴力解怎么写、能通过，也知道这样写效率低、不优雅，那就别写暴力解了，时间宝贵，不如仔细审题，发现规律，把时间花在自己写出高效解法上。
* 一道题，拿到手看了20分钟，啥思路都没有？别想了。写了30分钟，连暴力解都A不了？别写了。不要浪费太多时间，直接看题解！总结：**不恋战！**
* 接着上一条：**做题要计时**，心里有底。

2021.11.26

### 字符串第2轮 - 20道简单题

#### [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

> 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
>
> 字符          数值
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000
> 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
>
> I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
> X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
> C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
> 给定一个罗马数字，将其转换成整数。
>
> 示例 1:
>
> 输入: s = "III"
> 输出: 3
> 示例 2:
>
> 输入: s = "IV"
> 输出: 4
> 示例 3:
>
> 输入: s = "IX"
> 输出: 9
>
> 输入: s = "MCMXCIV"
> 输出: 1994
> 解释: M = 1000, CM = 900, XC = 90, IV = 4.
>
>
> 提示：
>
> 1 <= s.length <= 15
> s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
> 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
> 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。

这题的题目描述略长，但是看懂了怎么算（就是给一个正确的罗马数字，你能在纸上算出来，这就叫**手写会算**，只是差**代码实现**）。

怎么算？从字符串末尾往前遍历，即从右往左遍历。

* 首先解决单个罗马数字的转化问题：因为只有7个，7种情况，所以直接多写一个方法，用swtich返回对应值即可。

  评论区也有人用哈希表存对应关系的，虽然也是O(1) O(1)，但是每次运行都要手动加入键值对，又不好看，又浪费空间时间，不如直接写死在方法里。

* 正常情况下，每次都给最终值加上这个罗马数字所对应的阿拉伯数字（如V对应5）。所以要声明一个变量存最终值，或者说总和。
* 特殊情况下，会遇到当前罗马数字比它右边的罗马数字小，此时需要减去当前罗马数字的对应阿拉伯数字。所以要声明另一个变量存目前遇到的最大的罗马数字（正常情况下，从右往左是非降序的，所以“比它右边的罗马数字小”其实也就是“比目前遇到过的最大罗马数字小”）。

---

*记录一点题外话，这题我今天花了25分钟A了，一次提交成功。*

*成绩：96% 87% 4ms 38.4MB 时间O(N) 空间O(1)。*

*代码：*

```java
class Solution {
    public int romanToInt(String s) {
        int len = s.length();
        int value = 0;
        int largestNum = getInteger(s.charAt(len - 1));
        for(int i = len - 1; i >= 0; i--) {
            int currentNum = getInteger(s.charAt(i));
            if(currentNum > largestNum) {
                value += currentNum;
                largestNum = currentNum;
            }
            else if(currentNum == largestNum) {
                value += currentNum;
            }
            else {
                value -= currentNum;
            }
        }
        return value;
    }

    public int getInteger(char romanNumeral) {
        switch(romanNumeral) {
            case 'I': return 1;
            case 'V' : return 5;
            case 'X' : return 10;
            case 'L' : return 50;
            case 'C' : return 100;
            case 'D' : return 500;
            case 'M' : return 1000;
            default : return -1;
        }
    }
}
```

*而当年第一次刷力扣的我（9个月前），写了不知道多久，从一次提交就通过来看，应该是自己写不出来，看题解才做出来的。*

*成绩：31% 22% 7ms 39MB 时间O(N) 空间O(1)*

```java
class Solution {
    public int romanToInt(String s) {
        char[] roman = s.toCharArray();
        Map<Character, Integer> hashmap = new HashMap<Character, Integer>();
        hashmap.put('I', 1);
        hashmap.put('V', 5);
        hashmap.put('X', 10);
        hashmap.put('L', 50);
        hashmap.put('C', 100);
        hashmap.put('D', 500);
        hashmap.put('M', 1000);
        int sum = 0;
        for(int i=0; i<roman.length; ) {
            if(i==roman.length-1) {
                sum += hashmap.get(roman[i]);
                return sum;
            }
            int a = hashmap.get(roman[i]);
            int b = hashmap.get(roman[i+1]);
            if(a<b) {
                sum += b-a;
                i += 2;
            }
            else {
                sum += a;
                i++;
            }
        }
        return sum;
    }
}
```

*差距，进步，一目了然。*

---

#### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

> 编写一个函数来查找字符串数组中的最长公共前缀。
>
> 如果不存在公共前缀，返回空字符串 ""。
>
> 示例 1：
>
> 输入：strs = ["flower","flow","flight"]
> 输出："fl"
> 示例 2：
>
> 输入：strs = ["dog","racecar","car"]
> 输出：""
> 解释：输入不存在公共前缀。
>
>
> 提示：
>
> 1 <= strs.length <= 200
> 0 <= strs[i].length <= 200
> strs[i] 仅由小写英文字母组成

首先想到，纵向扫描每一个字符串的第n位前缀字符，如果都相等，则该字符可以“加入”公共前缀字符串，然后继续纵向扫描第n+1位前缀字符；如果有不相等的，则所有循环结束，上一轮得到的公共前缀字符串就是最终结果。

这里有两层循环，外层循环次数是纵向扫描的字符个数，即所有字符串中最短那个的长度（公共前缀字符串的长度不会超过它）；内层循环次数是字符串数组的长度。

所以要先找到最短字符串的长度，再来两个for遍历，时间O(N*N)，空间O(N)。

2021.11.27



#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
>
> 输入：s = "([)]"
> 输出：false
> 示例 5：
>
> 输入：s = "{[]}"
> 输出：true
>
>
> 提示：
>
> 1 <= s.length <= 104
> s 仅由括号 '()[]{}' 组成

括号匹配问题是栈的经典应用场景之一。这题的思路非常清晰，不需要再记什么思路笔记了。*（想起当初第一次做力扣的时候做这些题真是太难了）*

2021.11.29



#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

> 说明：
>
> 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
> 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
>
> 提示：
>
> 0 <= haystack.length, needle.length <= 5 * 104
> haystack 和 needle 仅由小写英文字符组成

借用评论区最高赞```@取个名字真难```的评论：

> 无语，这种题目就算了吧。要是说考察寻找字串快的可以用到KMP等方法，难度应该要归类到困难。要是用各种语言的内置函数，又不知道作为一道算法题的意义何在？考察对语言的熟悉程度？差评！

我用暴力解的，提交一次过，具体算法不说了，暴力解很简单的，这题对于现在的我来说确实没什么营养（但是研究KMP又没必要）。

后来我又回看9个月前的提交，优化了一个小细节（判断匹配成功不用flag，直接看targetIndex有没有走完就行），成绩大概在10% 90%，不纠结了。KMP算法实在复杂，以后再说。

*还有个事，就是我用9个月前的同一份代码去提交，出来的执行用时、内存消耗和之前完全不一样，而且相差非常大——相差几个量级，我也不知道为什么，困惑。*

2021.11.30



#### [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

> 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。
>
> 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
>
> 示例 1：
>
> 输入：s = "Hello World"
> 输出：5
> 示例 2：
>
> 输入：s = "   fly me   to   the moon  "
> 输出：4
>
>
> 提示：
>
> 1 <= s.length <= 104
> s 仅有英文字母和空格 ' ' 组成
> s 中至少存在一个单词

这题拿到手，第一个想到从后往前遍历，遇到空格就停，这样最后一个单词的长度就算出来了嘛。

但是我忽略了示例2，如果最后面是空格呢，我自己AC的低效解法是用一个boolean变量记录是否遇到过非空格字符，再用一个int变量记录（从后往前数）第一个空格字符的下标，这样也能AC，*100% 50%——看起来不错？100%是因为0ms，看一下详情就知道0ms占通过的一半，毕竟这题实现O(N) O(1)没什么难度。这时候就要挑战一下，看能否改得更简洁更省内存了。*

我在题解区看到一个非常优雅的代码（100% 90%），短到我可以直接贴上来：（我参照他的思路自己写了一个100% 80%，代码没这个优雅，因为我在while里面还写了一对简单的if-else——其实**简单的if-else一般是可以想办法精简掉的**）

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int i = s.length() - 1;
        while(i >= 0 && s.charAt(i) == ' ') i--;        //去掉末尾的空格字符，找到最后一个非空格字符的下标i
        int j = i;
        while(j >= 0 && s.charAt(j) != ' ') j--;        //从i开始,从后往前，找到第一个空格字符的下标j
        return i - j;
    }
}
```

这个思路是不一样的，这里我们**先去除字符串最后的空格**，再回到最简单的最初的算法——找到空格。

2021.12.01

#### [67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

> 给你两个二进制字符串，返回它们的和（用二进制表示）。
>
> 输入为 非空 字符串且只包含数字 1 和 0。
>
> 示例 1:
>
> 输入: a = "11", b = "1"
> 输出: "100"
> 示例 2:
>
> 输入: a = "1010", b = "1011"
> 输出: "10101"
>
>
> 提示：
>
> 每个字符串仅由字符 '0' 或 '1' 组成。
> 1 <= a.length, b.length <= 10^4
> 字符串如果不是 "0" ，就都不含前导零。

自己写了40分钟没写出来，代码太长太繁复了，遂放弃，转向题解区寻求答案。

p.s.说在前面：为什么这个解法28% 58%我都采用？因为看评论区，似乎有很多人都是流氓解法，调用现成函数，三行搞定。这种我们不管它，但它确实会影响平均成绩。而且这题我光理解正确题解也看了挺久的，所以，点到为止，不追求再复杂再高效的。下次遇到再研究。

回归正题，其实这题最关键的就是一个**二进制的进位问题**，搞懂了进位，实现的时候用暴力解法，写各种if-else，就算不优雅不简洁，也总归是可以AC的。我AC不了就是因为二进制的进位没搞懂。

整体思路如下：

1. 我们先声明一个StringBuffer对象，用来生成结果数字（一位一位append上去）。然后对代表二进制数字的两个字符串进行倒序遍历，**逐位相加、进位**。最后把这个StringBuffer翻转一下（从低位到高位的倒序遍历，加进StringBuffer里的结果是正序的低位到高位），就是我们的最终结果，然后toString()返回。

2. 在逐位相加、进位之前，我们需要声明一个`n`变量，存储较长字符串的长度。为什么不是较短的？因为我们需要遍历到每一位数，哪怕较长字符串的那一位数字，在较短字符串中没有对应数字跟它相加，也要遍历到那里，做相应处理。

   * 这里你其实也可以先手动给较短字符串的前面补上足够的“0”，直到两个字符串长度一致，就没用长短之分了。

3. 还需要声明一个`carry`变量，存储目前需要进位多少当前位数。

   * 以十进制为例可能比较容易说明一点：比如我现在要开始做百位的相加，carry为1就说明，我现在有一个额外的“百”想要加进结果里。

   * 二进制同理，如果此时正在计算2^3（十进制8）位，carry为1就说明我有一个额外的2^3想要加进这个结果里，比如它可能来自于""0111"+"0111"（补上0方便演示），也可能来自于"1000"+"0000"。

4. 其实搞懂怎么进位，这题就明了。我们倒序遍历每一位数并相加（遇到不存在的位数，就当作0来加；或者你已经手动补过0了，这里就不用判断）直到遍历完较长字符串，即遍历了n次。

5. 加之前，carry已经带着上一轮留下来的需要进位的数值了，可能是0，也可能是1。然后，你需要对两个字符串的对应数字，各自来一次`carry+=0或1`。

6. 然后，现在carry记录的，就是结果需要加上的值。`append(carry%2)`，然后再`carry/=2`，同一位数的相加就完成了。

2021.12.02做，2021.12.03记



#### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
>
> 说明：本题中，我们将空字符串定义为有效的回文串。
>
> 示例 1:
>
> 输入: "A man, a plan, a canal: Panama"
> 输出: true
> 解释："amanaplanacanalpanama" 是回文串
> 示例 2:
>
> 输入: "race a car"
> 输出: false
> 解释："raceacar" 不是回文串
>
>
> 提示：
>
> 1 <= s.length <= 2 * 105
> 字符串 s 由 ASCII 字符组成

借用某题解的评论区大佬的评论：

> 回文的常见的3种做法：双指针，栈，reverse

经典**回文串问题**，三个经典思路之中，

* 栈，我确实没想到；
* StringBuffer的reverse()，我知道，不过觉得简单调api不太好，就没选（其实要处理大小写问题还是要多写几行的）
* 所以我用双指针做

一开始只调用了一个现成方法`replaceAll("[^A-Za-z0-9]", "")`，把无关字符全都删掉。

剩下的，思路其实非常非常非常简单，就是对`charAt(left)`和`charAt(right)`做比较，但由于它们有数字、小写字母、大写字母三种情况，所以我是用ascii表转的，如果是数字，就比较两个字符是否相等；如果是字母，就比较它们之差的绝对值是否等于0或32。

但是这样成绩大概只有10% 10%，最后看了题解，改用“全api”解法，而且删去前面的replaceAll正则表达式匹配（这个似乎是最消耗时间空间的），然后在循环中全部调用Character的静态方法，包括

```
isLetterOrDigit()		//不符合就left++或right--
isDigit()				//是数字字符就直接比较；是字母字符的话，需要考虑大小写问题再比较
isLowerCase()			//小写统一转大写，大写不用变
toUpperCase()
```

成绩70% 70% 3ms 38.4MB，还可以。

2021.12.5



字符串通过6题

字符串第2轮 - 小结&经验&感悟

* **尽量让通过率达到100%**，尽量不要出现”解答错误“的情况。要学会**自己写测试用例**，因为实际写程序的过程中，你必须在程序正式投入使用（提交）之前尽可能预料到所有可能的情况，而不是等报错了、出现Bug了再回来改代码——这是思想上的问题。