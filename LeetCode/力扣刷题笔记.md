# 力扣刷题记录

## 刷题方法论

参考：

[大一计算机学生如何高效刷力扣？ - 知乎](https://www.zhihu.com/question/392882083)

怎么刷？

> @82DF-5C82：
>
> 如果学过算法和数据结构，那每天刷就行了。
>
> 第一遍以结果正确为目标，不追求运行效率，长时间没思路就看参考代码，遇到没学过的算法和数据结构就补一下。
>
> 第二遍以运行效率为目标，追求尽可能低的算法复杂度，同时加强记忆。
>
> 还有余力的话再刷第三第四遍，以熟练为目标，规定自己每题在有限的时间内AC。
>
> 最开始肯定会很吃力，慢慢地就好了。另外也要慢慢接触除了算法以外的知识体系以及工程实践，然后逐渐找到自己的方向，不要沉迷经典算法。

刷什么？

>  @代码随想录：
>
>  * 第一轮
>
>  题目类别推荐按照这个顺序来说： **数组 ->字符串 ->链表->二分查找->排序->哈希表-> 栈->队列 ->树 、递归、回溯 -> 堆** ，每一个类别只做简单的题目！而且是从通过率又高向低来刷。
>
>  这样刷过一遍之后 我们基础的数据结构和算法就已经差不多了
>
>  * 第二轮
>
>  开始做第一轮类别里面中等难度的题目
>
>  * 第三轮
>
>  这一轮的题目所代表的算法是比较难的，如果之前没有了解过，直接就刷题会很难，所以，建议把相关算法的理论看一遍，再去刷题， **先了解一下 什么是 拓扑排序、 分治，搜索树，贪心，动态规划，以及深搜和广搜**，然后再去刷题
>
>  推荐按照这个顺序去做：**拓扑排序->分治算法-> 二叉搜索树->贪心算法->动态规划-> 深度优先搜索 -> 广度优先搜索-->图->数学**
>
>  这里依然还是只做简单难度的题目 按照通过率又高向低
>
>  * 第四轮
>
>  开始尝试做第一轮里面的 困难难度的题目 （不强求，仅仅是尝试，面试中也不会太难）
>
>  同时开始做第二轮里面 中等难度的题目 （不用全都做，选一下自己一看就有想法的题目）
>
>  * 第五轮
>
>  然后开始做做leetcode分类里面 第一轮和第二轮都没有涉及到的类别的题目，相对于其他类型，面试中最常考察的是： **字典树-> 并查集 -> 树状数组->线段树 ， 这里只做简单难度的就可以了！**
>
>  剩余类型题目也凭个人喜好，选一些简单难度的题目做一做就可以了。

## 第1轮

### 数组 - 简单

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> 示例 1：
>
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

这题简单，直接看官方题解即可。（我的两次AC的思路和官方题解差不多）

一个是暴力枚举，O(N*N)，O(1)，能AC但成绩很差；

一个是哈希表，这也是典型的**把数组遍历的两层遍历O(N*N)改为一层遍历O(N)的思路，就是存入哈希表**，这样查找的时间效率为O(1)，当然，会牺牲一定的空间。

还有值得注意的是，**“存入哈希表”最高效的方法是【边找边存】O(N)，而不是【存完再找】O(2N)**——后者是我第二次AC的思路，就是先遍历一遍存入全部元素，然后遍历一遍来找，同样能AC但成绩很差；前者是官方题解的，确实妙。
2021.11.01AC

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使每个元素**只出现一次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在**原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
>
>  示例 2：
>
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
>
> 提示：
>
> - `nums` 已按升序排列

注意三个条件：原地修改，空间O(1)，升序数组
我的AC思路其实就是官方题解中的双指针，preIndex相当于slow指针，i相当于fast指针，但我还记录了一个preNum，通过对比当前元素是否与上一个被加入的元素相同，来判断当前元素是否为新元素。但这是没有必要的（消耗空间），其实只需要比较一个元素是否和它的上一个元素不同就可以了。
至于官方题解的【快慢双指针】，再配合【判断是否与前一个元素相同来判断是否为重复元素】，真是太优雅了。

2021.11.02AC

#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 `nums` 和一个值 `val`，你需要**原地**移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2：
>
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

26题的增强版，不过26是要删除重复项，27是要删除特定项，此时只有两个条件：原地修改，空间O(1)。

不过照样可以用【快慢双指针】搞定，思路与26很相似。

2021.11.02AC

#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给定一个已按照 **非递减顺序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。
>
> 函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

既然是有序数组，那就要利用好“有序”这个性质，查找有序数组？那就是二分查找了。
但是一开始写二分查找我没写对（边界出了问题），后来用了LeetBook二分查找的模板1（后来发现官方题解1也是这个）才AC，但是只有36% 29%。*如果把这种成绩视为可以的话，那对这道题是一种浪费。*
看了官方题解2，没想到还有【左右双指针】这种时间效率O(N)的解法：把左指针放到最前，把右指针放到最后，计算两个指针对应元素之和，与target做比较，太大了要变小就让右指针往左挪，毕竟左指针已经最小了；太小了要变大就让左指针往右挪，毕竟右指针已经最大了。

那有没有可能错过？如果正确的下标是2和5，那么left有没有可能走到比2大的地方？right有没有可能走到比5小的地方？答案是：不可能。其实比较难理解的就在于“临界点”处。

假设left先走到了2，这时候right还太大，和也太大（left必须停下，不可能再右移），必须左移right，直至right走到5。同理，假设right先走到了5，这时候left还太小，和也太小（right必须停下，不可能再左移），必须右移left，直至left走到2。
2021.11.06AC

以上笔记为2021.11.07首次整理到markdown上

---

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
>  **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```

排序数组找目标值，时间复杂度O(log n)...就差直接把“二分查找”四个大字写出来了。

没关系，直接写即可。不得不说LeetBook给的二分模板真好用。

这个题目比普通二分就多了个条件：哪怕找不到，也要返回合适的插入位置。**结合代码和画图**可知，如果找不到，那么最后一轮一定是left/right/mid挤在同一位置，然后target > nums[mid]，然后left = mid + 1，接着left > right所以跳出循环。此时left所处位置就是插入位置。

这题很简单（也是因为我以前在力扣的另一进度做过），但是却有点感悟，那就是：**理解算法一定要多画图！**

2021.11.07

#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>
> **示例 1：**
>
> ```
> 输入：digits = [1,2,3]
> 输出：[1,2,4]
> 解释：输入数组表示数字 123。
> ```
>
> **提示：**
>
> - `1 <= digits.length <= 100`
> - `0 <= digits[i] <= 9`

直接在数组上求解即可，我的100% 80%AC思路是，从数组末尾开始遍历，

1. 如果当前数字是0~8，则直接+1返回原数组

2. 如果当前数字是9，则设为0，然后继续对下一位（i--）数字进行同样的判断，即进位——下一位数字要么+1，要么继续进位。（也可以写成递归）
3. 特殊情况，要是没有下一位，但仍需进位，也就是{9, 9, 9}的情况，就要作特殊处理一下，返回一个新数组。

看起来我的解法比较符合人类思维，其实就是模拟演算过程。

官方解法也很巧妙，它同样从数组末尾开始遍历，不过它是先找到第一个不为9的数字，让这个数字+1，然后这个数字右边的数字全部设置为0；如果所有数字都为9，那也很简单，特殊处理一下就好。

2021.11.08

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。
>
> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
>
> **注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> ```

一次过。

想要时间O(N)就用双指针。

想要空间O(1)就别用额外的数组，在原数组空间上改。

既然nums1后n位都是0，那就从后往前（从大往小）地遍历，用额外的指针记录待插入位置**nums1[j]**，用双指针找到nums1的待插入元素**nums1[i1]**和nums2的待插入元素**nums2[i2]**，再选择比较大的那个插入。

为什么while循环的循环条件是i2 >= 0？首先，既然是在num1的基础上合并nums1和nums2，nums2的元素全要搬到nums1，也就是说如果还没遍历完整个nums2，那肯定还没有完成合并；而遍历完整个nums2，也就标志着合并过程的结束。

为什么while循环条件不需要&& i1 >= 0？其实是需要的，不然i1--要是减成-1了，nums1[-1]就根本没法比较，所以在while循环体里的if-else条件中，先加一个i1 >= 0，万一i1真的不满足这个条件，就说明nums1原来的所有元素都已经搞定了，但显然nums2的还没有，所以就走else，插入nums2的元素。

为什么while循环条件不需要&& j >= 0？emmm，这个你自己算一下就知道。if-else任选一个都会移动双指针中的其中一个指针，i1从(m-1)到0最多m次，i2从(n-1)到0最多n次，哪怕i2没有提前走完（i2走完，循环体就结束），而是等i1先走完，那整个循环体最多也就走m+n次，而j从(m+n-1)到0最多也就m+n次，刚好。

2021.11.09

#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![1626927345-DZmfxB-PascalTriangleAnimated2.gif (260×240)](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>

题目上的gif图已经把本题的解法展示得清清楚楚了......这个提示太过了吧。

杨辉三角1太简单，顺便做一下杨辉三角2——

#### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

> 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
> **示例 1:**
>
> ```
> 输入: rowIndex = 3
> 输出: [1,3,3,1]
> ```

跑完杨辉三角1的代码，再返回对应row的List对象，就能AC，但是最优雅的解法肯定不是这样。没办法，看题解吧。

要获取第i行的元素，肯定需要第i-1行的；要获取i-1行的，肯定要获取i-2行的，那**O(N)**的时间复杂度是逃不过了，事实也确实如此（不考虑直接用杨辉三角的数学公式，仅仅用题目描述给的设定的话）。但空间复杂度呢？要一行一行地算，就必须一行一行地存吗？还真不少，我们可以在**“原地”修改List对象**！这样可以把空间复杂度从O(N)降到**O(1)**。

解法如下：

先手动存好第0行，然后从第1行开始遍历到第rowIndex行。

* 官方题解的方案：新行其实就是在上一行的List对象中先add一个0在末尾，元素个数就多了一个。然后从新行的第rowIndex个元素开始遍历到第1个元素（第0个元素一直为1，不用改动）。新行加的这个0的巧妙之处就在于我们这样遍历的时候，不用专门为新行的最后一个元素，即1，专门写一个add，而是可以和其他位置的元素一样，通过【上一行的第i个元素与第i-1个元素之和】来求值。

  我觉得这种写法实在没有必要，不如采用第二种。

* 另一种方案：新行先尾插入一个1（而不是0），然后从第rowIndex-1个元素开始遍历到第1个元素，或者正着遍历，都可以。这种写法比较符合正常逻辑。

2021.11.10