# 二分查找-第一轮 刷题记录

## 前言

基于LeetBook：[二分查找 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode-cn.com/leetbook/detail/binary-search/)

关于二分查找，704题的题解区有一篇文章分析得很到位。原文：[二分查找细节详解，顺便赋诗一首 - 二分查找 - 力扣（LeetCode）](https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/)

> 二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：思路很简单，细节是魔鬼。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 <= 还是 <。
>
> 你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。

这段评价真是一阵见血。

我觉得，大家都懂得二分思想，但是**只有能够独立写出无bug、一次性AC的二分算法，才算是把二分学明白了**。如果只是靠看评论、看题解、看提交不通过的报错，最终跌跌撞撞把一道题做出来了，那么这不是我想要达到的水平。

## 背景

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

> **示例 1:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> ```
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

这题其实我在2021.11.06做过一次，不过当时没有记录，也没有写笔记。这次重做一遍就当复习吧，顺便补一下笔记。

**看到有序数组+无重复元素。就要想到用二分查找了**，因为这是二分查找最经典的应用场景。

不过我第一次做的时候甚至还写不出来一个能用的二分，只好直接套模板，就是下面的模板1。

## 二分查找模板1

#### 模板1

```java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0) {
      return -1;
  }
  int left = 0;
  int right = nums.length - 1;
  while(left <= right){
    //避免(left + right)溢出
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){
        return mid;
    }
    else if(nums[mid] < target) {
        left = mid + 1;
    }
    //相当于else if(nums[mid] > target)
    else {
        right = mid - 1;
    }
  }
  //退出循环时，left > right
  return -1;
}
```

#### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

> **示例 1：**
>
> ```
> 输入：x = 4
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：x = 8
> 输出：2
> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
> ```
>
> **提示：**
>
> - `0 <= x <= 2^31 - 1`

最终我还是参考了评论区，才能AC这道题。

因为我自己写的时候没能解决mid * mid溢出这个问题，事实上由于mid最大可以取Integer.MAX_VALUE / 2（当left=0, right=Integer.MAX_VALUE），这就意味着mid * mid的值一旦溢出，那将毫无规律可言。可能是正数，可能是负数，可能很大，可能很小。*（第一次提交：解答错误）*

评论区大佬的思路是，不要判断mid * mid == x，而是判断x / mid == mid，马上解决问题。

然后问题又来了，当x取1或者0时，mid会等于0，x除以0直接报错。*（第二次提交：执行错误）*

只要在程序前面写了个针对0和1的特殊处理，虽然很丑，但终于能通过了。*（第三次提交：通过）*

这样其实是不够的，我还是需要借助评论区/题解区大佬+提交不通过返回的信息才能做出这道题……但是没关系，开始阶段，先把题做出来就好，等二分查找的题做了一定量之后，再来总结分析，**先量变，再质变**。





上次看到
https://leetcode-cn.com/leetbook/read/binary-search/xee4ev/